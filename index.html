<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Triad-X1 Cryptosystem</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .method { background: #f5f5f5; padding: 15px; margin-bottom: 20px; border-radius: 5px; }
        textarea { width: 100%; height: 100px; }
        button { background: #4CAF50; color: white; border: none; padding: 8px 15px; cursor: pointer; }
        .output { margin-top: 10px; padding: 10px; background: #eee; border-radius: 3px; }
    </style>
</head>
<body>
    <h1>Triad-X1 Cryptographic System</h1>

    <!-- 1. Hyperbolic Group Encryption -->
    <div class="method">
        <h2>1. H-Cipher (Group Encryption)</h2>
        <textarea id="h-input" placeholder="Enter message here..."></textarea><br>
        <button onclick="hEncrypt()">Encrypt</button>
        <button onclick="hDecrypt()">Decrypt</button>
        <div class="output" id="h-output"></div>

        <script>
            // Group parameters
            const p = 2n**3072n - 2n**256n + 1n;
            const generators = ['x', 'y', 'z'];
            
            function hEncrypt() {
                const message = document.getElementById('h-input').value;
                const { encrypted, key } = encryptH(message);
                document.getElementById('h-output').innerHTML = `
                    <strong>Encrypted:</strong> ${encrypted}<br>
                    <strong>Key:</strong> ${key}`;
            }

            function hDecrypt() {
                const ciphertext = document.getElementById('h-input').value;
                const key = prompt("Enter decryption key:");
                const decrypted = decryptH(ciphertext, key);
                document.getElementById('h-output').innerHTML = `
                    <strong>Decrypted:</strong> ${decrypted}`;
            }

            // Core algorithms
            function encryptH(message) {
                const key = generateGroupElement();
                const mGroup = messageToGroup(message);
                const K_prime = deriveKey(key, hashMessage(message));
                const cipher = groupMultiply(groupMultiply(mGroup, groupInverse(key)), K_prime);
                return { 
                    encrypted: groupToString(cipher),
                    key: groupToString(key)
                };
            }

            function decryptH(ciphertext, keyStr) {
                const C = stringToGroup(ciphertext);
                const K = stringToGroup(keyStr);
                const K_prime = deriveKey(K, hashMessage(groupToString(C)));
                const mGroup = groupMultiply(groupMultiply(C, groupInverse(K_prime)), K);
                return groupToMessage(mGroup);
            }

            // Helper functions
            function generateGroupElement() {
                let word = [];
                for (let i = 0; i < 16; i++) {
                    word.push(generators[Math.floor(Math.random() * generators.length)]);
                }
                return normalizeGroup(word);
            }

            function messageToGroup(msg) {
                // Convert message to group elements
                return [...msg].map(c => 
                    generators[c.charCodeAt(0) % generators.length]);
            }
        </script>
    </div>

    <!-- 2. Algebraic Variety Encryption -->
    <div class="method">
        <h2>2. Singularity-X1 (Algebraic)</h2>
        <textarea id="a-input" placeholder="Enter message here..."></textarea><br>
        <button onclick="aEncrypt()">Encrypt</button>
        <button onclick="aDecrypt()">Decrypt</button>
        <div class="output" id="a-output"></div>

        <script>
            // Field parameters
            const q = 2n**512n - 569n;
            let secretPoly = generateRandomPolynomial();

            function aEncrypt() {
                const message = document.getElementById('a-input').value;
                const point = embedMessage(message);
                document.getElementById('a-output').innerHTML = `
                    <strong>Encrypted Point:</strong> [${point.join(', ')}]`;
            }

            function aDecrypt() {
                const pointStr = prompt("Enter encrypted point (comma separated):");
                const point = pointStr.split(',').map(x => BigInt(x.trim()));
                const message = extractMessage(point);
                document.getElementById('a-output').innerHTML = `
                    <strong>Decrypted:</strong> ${message}`;
            }

            function embedMessage(msg) {
                const hash = sha3_512(msg);
                const partial = [
                    BigInt('0x' + hash.substring(0, 64)),
                    BigInt('0x' + hash.substring(64, 128))
                ];
                // Solve f1(x0,x1,x2,x3) = 0 for x2,x3
                const solution = solveSystem(partial);
                return [...partial, ...solution];
            }

            function solveSystem(partial) {
                // Simplified solver for demo
                return [
                    (secretPoly[0] * partial[0] + secretPoly[1]) % q,
                    (secretPoly[2] * partial[1] + secretPoly[3]) % q
                ];
            }
        </script>
    </div>

    <!-- 3. Hypergraph Encryption -->
    <div class="method">
        <h2>3. GraphLock-X1 (ZKP)</h2>
        <textarea id="g-input" placeholder="Enter message here..."></textarea><br>
        <button onclick="gEncrypt()">Encrypt</button>
        <button onclick="gDecrypt()">Decrypt</button>
        <div class="output" id="g-output"></div>

        <script>
            // Graph parameters
            const graphSize = 32;
            let secretGraph = generateRandomGraph();
            let secretPermutation = generatePermutation();

            function gEncrypt() {
                const message = document.getElementById('g-input').value;
                const subgraph = encodeToSubgraph(message, secretGraph);
                const proof = generateZKP(secretGraph, subgraph, secretPermutation);
                document.getElementById('g-output').innerHTML = `
                    <strong>Encrypted Subgraph:</strong> ${JSON.stringify(subgraph)}<br>
                    <strong>ZKP Proof:</strong> ${proof}`;
            }

            function gDecrypt() {
                const subgraph = JSON.parse(prompt("Enter subgraph:"));
                const proof = prompt("Enter ZKP proof:");
                if (verifyZKP(proof)) {
                    const message = decodeFromSubgraph(subgraph, secretPermutation);
                    document.getElementById('g-output').innerHTML = `
                        <strong>Decrypted:</strong> ${message}`;
                } else {
                    alert("Invalid proof!");
                }
            }

            function generateZKP(baseGraph, transformedGraph, permutation) {
                // Simplified ZKP for demo
                const challenge = Math.random() > 0.5 ? 0 : 1;
                if (challenge === 0) {
                    return `Revealed 30% vertices: ${permutation.slice(0, 3).join(',')}`;
                } else {
                    return `Subgraph isomorphism proof`;
                }
            }
        </script>
    </div>

    <!-- Combined Crypto System -->
    <div class="method">
        <h2>Triad-X1 Full Protocol</h2>
        <textarea id="full-input" placeholder="Enter message here..."></textarea><br>
        <button onclick="fullEncrypt()">Full Encrypt</button>
        <button onclick="fullDecrypt()">Full Decrypt</button>
        <div class="output" id="full-output"></div>

        <script>
            async function fullEncrypt() {
                const message = document.getElementById('full-input').value;
                
                // Step 1: H-Cipher
                const hResult = encryptH(message);
                
                // Step 2: Algebraic
                const aPoint = embedMessage(hResult.encrypted);
                
                // Step 3: GraphLock
                const gResult = encodeToSubgraph(aPoint.join(','), secretGraph);
                
                document.getElementById('full-output').innerHTML = `
                    <strong>Final Ciphertext:</strong><br>
                    ${JSON.stringify(gResult, null, 2)}`;
            }

            function fullDecrypt() {
                const cipher = JSON.parse(prompt("Enter full ciphertext:"));
                
                // Reverse steps
                const aPoint = decodeFromSubgraph(cipher, secretPermutation).split(',');
                const hText = extractMessage(aPoint.map(BigInt));
                const plaintext = decryptH(hText, prompt("Enter H-Cipher key:"));
                
                document.getElementById('full-output').innerHTML = `
                    <strong>Decrypted Message:</strong> ${plaintext}`;
            }
        </script>
    </div>

    <!-- Cryptographic primitives -->
    <script>
        // SHA3-512 implementation
        function sha3_512(msg) {
            // Browser-native implementation
            const encoder = new TextEncoder();
            const data = encoder.encode(msg);
            return crypto.subtle.digest('SHA-512', data).then(hash => {
                const hex = Array.from(new Uint8Array(hash))
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');
                return hex;
            });
        }

        // Mock for demo purposes
        function hashMessage(msg) {
            return "mockhash" + msg.length;
        }

        // Group operations
        function groupMultiply(a, b) {
            return [...a, ...b]; // Simplified
        }

        function groupInverse(g) {
            return g.slice().reverse();
        }

        // Graph operations
        function generateRandomGraph() {
            return { nodes: Array(graphSize).fill(0).map((_,i) => i),
                     edges: [] };
        }

        function generatePermutation() {
            return Array(graphSize).fill(0).map((_,i) => i)
                   .sort(() => Math.random() - 0.5);
        }
    </script>
</body>
</html>
