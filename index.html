<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Triad-X1 Криптографическая Система</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/numpy/1.1.0/numpy.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/networkx/2.6.0/networkx.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/blake2b@1.2.0/blake2b.min.js"></script>
    <style>
        body {
            font-family: 'Courier New', monospace;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: #2c3e50;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        pre {
            background: #2c3e50;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            transition: background 0.3s;
        }
        button:hover {
            background: #2980b9;
        }
        .result {
            margin-top: 20px;
            padding: 15px;
            background: #e8f4fc;
            border-radius: 5px;
            font-family: monospace;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Triad-X1 Криптографическая Система</h1>
        
        <h2>1. H-Cipher X1 (Гиперболическое групповое шифрование)</h2>
        <pre id="hcipher-code">
class HCipher {
    constructor(dimension = 8, prime = BigInt(2)**BigInt(768) - BigInt(569)) {
        this.dim = dimension;
        this.p = prime;
        this.SL8 = this._generateSLGroup();
    }

    _generateSLGroup() {
        while (true) {
            let M = new Array(this.dim);
            for (let i = 0; i < this.dim; i++) {
                M[i] = new Array(this.dim);
                for (let j = 0; j < this.dim; j++) {
                    M[i][j] = BigInt(Math.floor(Math.random() * Number(this.p)));
                }
            }
            // Упрощенная проверка детерминанта (в реальной реализации нужен точный расчет)
            if (Math.random() > 0.5) return M; // Имитация условия
        }
    }

    encrypt(message) {
        const msgMatrix = this._messageToMatrix(message);
        let encrypted = new Array(this.dim);
        for (let i = 0; i < this.dim; i++) {
            encrypted[i] = new Array(this.dim);
            for (let j = 0; j < this.dim; j++) {
                let sum = BigInt(0);
                for (let k = 0; k < this.dim; k++) {
                    sum += BigInt(this.SL8[i][k]) * BigInt(msgMatrix[k][j]);
                }
                encrypted[i][j] = sum % this.p;
            }
        }
        return this._matrixToBytes(encrypted);
    }

    _messageToMatrix(msg) {
        const padSize = (this.dim**2 - msg.length) % this.dim**2;
        const msgPadded = new Uint8Array([...msg, ...new Array(padSize).fill(padSize)]);
        
        let matrix = new Array(this.dim);
        for (let i = 0; i < this.dim; i++) {
            matrix[i] = new Array(this.dim);
            for (let j = 0; j < this.dim; j++) {
                const idx = i * this.dim + j;
                matrix[i][j] = idx < msgPadded.length ? BigInt(msgPadded[idx]) : BigInt(0);
            }
        }
        return matrix;
    }
}</pre>
        
        <h2>2. Singularity-X1 (Алгебраическое многообразие)</h2>
        <pre id="singularity-code">
class SingularityCipher {
    constructor(dimension = 6, fieldSize = BigInt(2)**BigInt(512)) {
        this.dim = dimension;
        this.field = fieldSize;
    }

    encrypt(message) {
        const msgInt = BigInt('0x' + [...message].map(b => 
            b.toString(16).padStart(2, '0')).join('')) % this.field;
        
        const coords = [msgInt];
        for (let i = 1; i < this.dim; i++) {
            const x_i = (msgInt + BigInt(i))**BigInt(3) % this.field;
            coords.push(x_i);
        }
        
        return coords.map(c => {
            const hex = c.toString(16).padStart(128, '0');
            return new Uint8Array(hex.match(/../g).map(h => parseInt(h, 16)));
        });
    }
}</pre>
        
        <h2>3. GraphLock X1 (Гиперграфовый изоморфизм)</h2>
        <pre id="graphlock-code">
class GraphLock {
    constructor(vertexCount = 256, degree = 3) {
        this.G = this._generateRegularGraph(vertexCount, degree);
        this.H = null;
        this.isomorphism = null;
    }

    _generateRegularGraph(n, d) {
        const nodes = Array.from({length: n}, (_, i) => i);
        const edges = new Set();
        
        // Простое создание регулярного графа (в реальной реализации более сложная логика)
        for (let i = 0; i < n; i++) {
            for (let j = 1; j <= d; j++) {
                const neighbor = (i + j) % n;
                edges.add(`${i}-${neighbor}`);
            }
        }
        
        return {
            nodes: nodes,
            edges: Array.from(edges).map(e => e.split('-').map(Number))
        };
    }

    encrypt(message) {
        const seed = blake2b(message).digest();
        const seedInt = BigInt('0x' + [...seed].map(b => 
            b.toString(16).padStart(2, '0')).join(''));
        
        // Перемешивание узлов на основе seed
        const shuffledNodes = [...this.G.nodes];
        for (let i = shuffledNodes.length - 1; i > 0; i--) {
            const j = Number(seedInt % BigInt(i + 1));
            [shuffledNodes[i], shuffledNodes[j]] = [shuffledNodes[j], shuffledNodes[i]];
        }
        
        this.H = {
            nodes: shuffledNodes,
            edges: this.G.edges.map(([u, v]) => 
                [shuffledNodes[u], shuffledNodes[v]])
        };
        
        this.isomorphism = shuffledNodes.reduce((map, node, idx) => {
            map[node] = idx;
            return map;
        }, {});
        
        return this.H.edges;
    }
}</pre>
        
        <h2>Гибридное шифрование Triad-X1</h2>
        <pre id="triad-code">
class TriadX1 {
    constructor() {
        this.hcipher = new HCipher();
        this.singularity = new SingularityCipher();
        this.graphlock = new GraphLock();
    }

    async encrypt(message) {
        // Конвертация сообщения в Uint8Array
        const msgBytes = new TextEncoder().encode(message);
        
        // Шаг 1: Групповое шифрование
        const hEnc = this.hcipher.encrypt(msgBytes);
        
        // Шаг 2: Алгебраическое шифрование
        const sEnc = this.singularity.encrypt(hEnc);
        
        // Шаг 3: Графовое преобразование
        const gEnc = this.graphlock.encrypt(sEnc[0]);
        
        return {
            h_cipher: Array.from(hEnc).map(b => b.toString(16).padStart(2, '0')).join(''),
            s_cipher: sEnc.map(arr => Array.from(arr).map(b => b.toString(16).padStart(2, '0')).join('')),
            g_cipher: gEnc.slice(0, 5), // Показываем только первые 5 ребер
            zkp_seed: this.graphlock.G.edges.slice(0, 3) // Пример ZKP
        };
    }
}</pre>
        
        <div>
            <h2>Демонстрация</h2>
            <textarea id="message-input" rows="3" style="width: 100%; padding: 10px;" 
                      placeholder="Введите сообщение для шифрования...">Тестовое сообщение</textarea>
            <button onclick="runEncryption()">Зашифровать</button>
            <div id="encryption-result" class="result">Результат появится здесь...</div>
        </div>
    </div>

    <script>
        // Реализация blake2b для браузера
        function blake2b(data) {
            const hash = new Uint8Array(64);
            // Упрощенная реализация - в реальной системе используйте библиотеку
            for (let i = 0; i < hash.length; i++) {
                hash[i] = data[i % data.length] ^ i;
            }
            return hash;
        }

        // Инициализация классов
        class HCipher { /* ... см. код выше ... */ }
        class SingularityCipher { /* ... см. код выше ... */ }
        class GraphLock { /* ... см. код выше ... */ }
        class TriadX1 { /* ... см. код выше ... */ }

        async function runEncryption() {
            const message = document.getElementById('message-input').value;
            const triad = new TriadX1();
            
            try {
                const result = await triad.encrypt(message);
                document.getElementById('encryption-result').innerHTML = 
                    `<strong>Исходное сообщение:</strong> ${message}\n\n` +
                    `<strong>H-Cipher (первые 32 байта):</strong> ${result.h_cipher.substring(0, 64)}...\n\n` +
                    `<strong>Singularity (первое значение):</strong> ${result.s_cipher[0].substring(0, 32)}...\n\n` +
                    `<strong>GraphLock (первые 5 ребер):</strong> ${JSON.stringify(result.g_cipher)}\n\n` +
                    `<strong>ZKP Seed (первые 3 ребра):</strong> ${JSON.stringify(result.zkp_seed)}`;
            } catch (error) {
                document.getElementById('encryption-result').innerHTML = 
                    `Ошибка: ${error.message}`;
            }
        }

        // Добавляем классы в глобальную область видимости для тестирования в консоли
        window.HCipher = HCipher;
        window.SingularityCipher = SingularityCipher;
        window.GraphLock = GraphLock;
        window.TriadX1 = TriadX1;
    </script>
</body>
        </html>
