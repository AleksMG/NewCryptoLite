<!DOCTYPE html>
<html>
<head>
    <title>Triad-X1 Full Crypto System</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0,0,0,0.1);
        }
        textarea {
            width: 100%;
            height: 120px;
            padding: 15px;
            margin: 15px 0;
            border: 1px solid #ddd;
            font-family: inherit;
        }
        button {
            background: #2c3e50;
            color: white;
            border: none;
            padding: 12px 20px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            margin-right: 10px;
            transition: background 0.3s;
        }
        button:hover {
            background: #1a252f;
        }
        .result {
            margin-top: 30px;
            padding: 20px;
            background: #f9f9f9;
            border: 1px solid #eee;
            border-radius: 5px;
            white-space: pre-wrap;
            font-size: 14px;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #2980b9;
            margin-top: 30px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Triad-X1 Cryptographic System</h1>
        
        <textarea id="input" placeholder="Enter your message here..."></textarea>
        
        <div>
            <button onclick="encrypt()">Encrypt</button>
            <button onclick="decrypt()">Decrypt</button>
            <button onclick="reset()">Reset</button>
        </div>
        
        <div class="result" id="result"></div>
        
        <h2>Technical Details</h2>
        <div id="tech-details"></div>
    </div>

    <script>
        // =============================================
        // CORE CRYPTOGRAPHIC COMPONENTS
        // =============================================
        
        // 1. Prime Number Utilities
        const PrimeUtils = {
            isPrime: function(n, k=5) {
                if (n <= 1n) return false;
                if (n <= 3n) return true;
                if (n % 2n === 0n) return false;
                
                let d = n - 1n;
                let s = 0n;
                while (d % 2n === 0n) {
                    d /= 2n;
                    s++;
                }
                
                for (let i = 0; i < k; i++) {
                    const a = 2n + BigInt(Math.floor(Math.random() * Number(n - 4n)));
                    let x = this.modPow(a, d, n);
                    if (x === 1n || x === n - 1n) continue;
                    
                    let composite = true;
                    for (let j = 1n; j < s; j++) {
                        x = this.modPow(x, 2n, n);
                        if (x === n - 1n) {
                            composite = false;
                            break;
                        }
                    }
                    if (composite) return false;
                }
                return true;
            },
            
            modPow: function(base, exp, mod) {
                let result = 1n;
                base = base % mod;
                while (exp > 0n) {
                    if (exp % 2n === 1n) {
                        result = (result * base) % mod;
                    }
                    exp = exp >> 1n;
                    base = (base * base) % mod;
                }
                return result;
            },
            
            generatePrime: function(bits) {
                const min = 1n << BigInt(bits - 1);
                const max = (1n << BigInt(bits)) - 1n;
                
                while (true) {
                    const candidate = min + BigInt(Math.floor(Math.random() * Number(max - min)));
                    if (this.isPrime(candidate)) {
                        return candidate;
                    }
                }
            },
            
            modInverse: function(a, m) {
                a = (a % m + m) % m;
                const [g, x] = this.extendedGCD(a, m);
                if (g !== 1n) throw new Error('No inverse exists');
                return (x % m + m) % m;
            },
            
            extendedGCD: function(a, b) {
                if (b === 0n) return [a, 1n, 0n];
                const [g, x, y] = this.extendedGCD(b, a % b);
                return [g, y, x - (a / b) * y];
            }
        };
        
        // 2. Matrix Operations in Finite Field
        class MatrixCipher {
            constructor(size=4, primeBits=256) {
                this.size = size;
                this.prime = PrimeUtils.generatePrime(primeBits);
                this.matrix = this.generateMatrix();
                this.inverseMatrix = this.calculateInverse();
            }
            
            generateMatrix() {
                let matrix;
                do {
                    matrix = [];
                    for (let i = 0; i < this.size; i++) {
                        matrix[i] = [];
                        for (let j = 0; j < this.size; j++) {
                            matrix[i][j] = BigInt(Math.floor(Math.random() * 100)) % this.prime;
                        }
                    }
                } while (this.determinant(matrix) === 0n);
                return matrix;
            }
            
            determinant(matrix) {
                const n = matrix.length;
                let det = 1n;
                const mat = matrix.map(row => [...row]);
                
                for (let i = 0; i < n; i++) {
                    if (mat[i][i] === 0n) {
                        let swapRow = -1;
                        for (let j = i + 1; j < n; j++) {
                            if (mat[j][i] !== 0n) {
                                swapRow = j;
                                break;
                            }
                        }
                        if (swapRow === -1) return 0n;
                        [mat[i], mat[swapRow]] = [mat[swapRow], mat[i]];
                        det = -det;
                    }
                    
                    const inv = PrimeUtils.modInverse(mat[i][i], this.prime);
                    for (let j = i + 1; j < n; j++) {
                        const factor = (mat[j][i] * inv) % this.prime;
                        for (let k = i; k < n; k++) {
                            mat[j][k] = (mat[j][k] - factor * mat[i][k]) % this.prime;
                            if (mat[j][k] < 0n) mat[j][k] += this.prime;
                        }
                    }
                }
                
                for (let i = 0; i < n; i++) {
                    det = (det * mat[i][i]) % this.prime;
                }
                return det;
            }
            
            calculateInverse() {
                const n = this.matrix.length;
                const inverse = Array(n).fill().map(() => Array(n).fill(0n));
                const identity = Array(n).fill().map((_, i) => 
                    Array(n).fill().map((_, j) => i === j ? 1n : 0n)
                );
                
                const mat = this.matrix.map((row, i) => [...row, ...identity[i]]);
                
                for (let i = 0; i < n; i++) {
                    if (mat[i][i] === 0n) {
                        let swapRow = -1;
                        for (let j = i + 1; j < n; j++) {
                            if (mat[j][i] !== 0n) {
                                swapRow = j;
                                break;
                            }
                        }
                        if (swapRow === -1) throw new Error('Matrix is not invertible');
                        [mat[i], mat[swapRow]] = [mat[swapRow], mat[i]];
                    }
                    
                    const inv = PrimeUtils.modInverse(mat[i][i], this.prime);
                    for (let j = 0; j < n; j++) {
                        if (j !== i && mat[j][i] !== 0n) {
                            const factor = (mat[j][i] * inv) % this.prime;
                            for (let k = i; k < 2 * n; k++) {
                                mat[j][k] = (mat[j][k] - factor * mat[i][k]) % this.prime;
                                if (mat[j][k] < 0n) mat[j][k] += this.prime;
                            }
                        }
                    }
                }
                
                for (let i = 0; i < n; i++) {
                    const inv = PrimeUtils.modInverse(mat[i][i], this.prime);
                    for (let j = 0; j < n; j++) {
                        inverse[i][j] = (mat[i][j + n] * inv) % this.prime;
                    }
                }
                
                return inverse;
            }
            
            encrypt(data) {
                const bytes = new TextEncoder().encode(data);
                const blocks = this.padData(bytes);
                let result = [];
                
                for (const block of blocks) {
                    const encrypted = this.processBlock(block, this.matrix);
                    result.push(...encrypted);
                }
                
                return new Uint8Array(result);
            }
            
            decrypt(data) {
                const blocks = this.padData(data);
                let result = [];
                
                for (const block of blocks) {
                    const decrypted = this.processBlock(block, this.inverseMatrix);
                    result.push(...decrypted);
                }
                
                // Remove padding
                const padLength = result[result.length - 1];
                if (padLength > 0 && padLength <= this.size * this.size) {
                    result = result.slice(0, -padLength);
                }
                
                return new TextDecoder().decode(new Uint8Array(result));
            }
            
            padData(data) {
                const blockSize = this.size * this.size;
                const padLength = (blockSize - data.length % blockSize) % blockSize;
                const padded = new Uint8Array(data.length + (padLength || blockSize));
                padded.set(data);
                
                if (padLength > 0) {
                    padded.fill(padLength, data.length);
                }
                
                return Array.from(
                    { length: padded.length / blockSize },
                    (_, i) => padded.slice(i * blockSize, (i + 1) * blockSize)
                );
            }
            
            processBlock(block, matrix) {
                const numbers = Array.from(block).map(x => BigInt(x));
                const result = new Array(this.size * this.size).fill(0n);
                
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        for (let k = 0; k < this.size; k++) {
                            const idx = i * this.size + j;
                            result[idx] += matrix[i][k] * numbers[k * this.size + j];
                            result[idx] %= this.prime;
                        }
                    }
                }
                
                return result.map(x => Number(x));
            }
        }
        
        // 3. Algebraic Variety Encryption
        class AlgebraicCipher {
            constructor(dimension=4, fieldBits=256) {
                this.dim = dimension;
                this.field = PrimeUtils.generatePrime(fieldBits);
                this.coefficients = this.generateCoefficients();
            }
            
            generateCoefficients() {
                const coeffs = [];
                for (let i = 0; i < this.dim; i++) {
                    coeffs[i] = [];
                    for (let j = 0; j < this.dim; j++) {
                        coeffs[i][j] = BigInt(Math.floor(Math.random() * 100)) % this.field;
                    }
                }
                return coeffs;
            }
            
            encrypt(data) {
                const bytes = new TextEncoder().encode(data);
                const numbers = Array.from(bytes).map(x => BigInt(x));
                const result = [];
                
                for (let i = 0; i < numbers.length; i += this.dim) {
                    const block = numbers.slice(i, i + this.dim);
                    const encrypted = this.processBlock(block);
                    result.push(...encrypted);
                }
                
                return new Uint8Array(result.map(x => Number(x)));
            }
            
            processBlock(block) {
                const result = new Array(this.dim).fill(0n);
                
                for (let i = 0; i < this.dim; i++) {
                    for (let j = 0; j < block.length; j++) {
                        result[i] += this.coefficients[i][j] * PrimeUtils.modPow(block[j], BigInt(j + 2), this.field);
                        result[i] %= this.field;
                    }
                }
                
                return result;
            }
        }
        
        // 4. Graph Isomorphism
        class GraphCipher {
            constructor(vertexCount=16, degree=4) {
                this.vertexCount = vertexCount;
                this.degree = degree;
                this.graph = this.generateGraph();
                this.permutation = this.generatePermutation();
            }
            
            generateGraph() {
                const edges = [];
                for (let i = 0; i < this.vertexCount; i++) {
                    for (let j = 1; j <= this.degree; j++) {
                        edges.push([i, (i + j) % this.vertexCount]);
                    }
                }
                return edges;
            }
            
            generatePermutation() {
                const perm = Array.from({length: this.vertexCount}, (_, i) => i);
                for (let i = perm.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [perm[i], perm[j]] = [perm[j], perm[i]];
                }
                return perm;
            }
            
            encrypt(data) {
                const bytes = new TextEncoder().encode(data);
                const numbers = Array.from(bytes);
                const result = [];
                
                for (let i = 0; i < numbers.length; i++) {
                    const encrypted = this.permutation[numbers[i] % this.vertexCount];
                    result.push(encrypted);
                }
                
                return new Uint8Array(result);
            }
        }
        
        // =============================================
        // TRIAD-X1 MAIN SYSTEM
        // =============================================
        class TriadX1 {
            constructor() {
                this.matrixCipher = new MatrixCipher();
                this.algebraicCipher = new AlgebraicCipher();
                this.graphCipher = new GraphCipher();
                this.encryptionSteps = [];
            }
            
            encrypt(message) {
                this.encryptionSteps = [];
                
                // Step 1: Matrix Encryption
                const matrixEncrypted = this.matrixCipher.encrypt(message);
                this.encryptionSteps.push({
                    name: "Matrix Cipher",
                    data: matrixEncrypted
                });
                
                // Step 2: Algebraic Encryption
                const algebraicEncrypted = this.algebraicCipher.encrypt(
                    matrixEncrypted
                );
                this.encryptionSteps.push({
                    name: "Algebraic Cipher",
                    data: algebraicEncrypted
                });
                
                // Step 3: Graph Encryption
                const graphEncrypted = this.graphCipher.encrypt(
                    algebraicEncrypted
                );
                this.encryptionSteps.push({
                    name: "Graph Cipher",
                    data: graphEncrypted
                });
                
                return graphEncrypted;
            }
            
            getEncryptionSteps() {
                return this.encryptionSteps;
            }
        }
        
        // =============================================
        // UI INTERACTION
        // =============================================
        const triadSystem = new TriadX1();
        let lastEncryptedData = null;
        
        function encrypt() {
            const input = document.getElementById('input').value;
            if (!input) {
                alert('Please enter a message to encrypt');
                return;
            }
            
            try {
                const encrypted = triadSystem.encrypt(input);
                lastEncryptedData = encrypted;
                
                const steps = triadSystem.getEncryptionSteps();
                let output = '=== Encryption Steps ===\n';
                
                steps.forEach(step => {
                    output += `\n[${step.name}]:\n`;
                    output += `Length: ${step.data.length} bytes\n`;
                    output += `Hex: ${Array.from(step.data)
                        .map(b => b.toString(16).padStart(2, '0'))
                        .slice(0, 32).join(' ')}${step.data.length > 32 ? '...' : ''}\n`;
                });
                
                output += '\n=== Final Encrypted Data ===\n';
                output += `Hex: ${Array.from(encrypted)
                    .map(b => b.toString(16).padStart(2, '0')).join(' ')}`;
                
                document.getElementById('result').textContent = output;
            } catch (error) {
                document.getElementById('result').textContent = `Error: ${error.message}`;
            }
        }
        
        function decrypt() {
            if (!lastEncryptedData) {
                alert('No encrypted data available. Encrypt first.');
                return;
            }
            
            document.getElementById('result').textContent = 
                "Full decryption not implemented in this demo.\n" +
                "Matrix decryption would be performed here.\n" +
                "In a complete system, all three layers would be reversed.";
        }
        
        function reset() {
            document.getElementById('input').value = '';
            document.getElementById('result').textContent = '';
            lastEncryptedData = null;
        }
    </script>
</body>
</html>
