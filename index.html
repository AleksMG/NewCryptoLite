<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Трифид-шифр (исправленный)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .panel {
            flex: 1;
            min-width: 300px;
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 5px;
        }
        textarea {
            width: 100%;
            min-height: 100px;
            margin-bottom: 10px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
        }
        .cube-display {
            margin-top: 20px;
            font-family: monospace;
        }
        .status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
        }
        .success {
            background-color: #dff0d8;
        }
        .error {
            background-color: #f2dede;
        }
    </style>
</head>
<body>
    <h1>Трифид-шифр (исправленная версия)</h1>
    
    <div class="container">
        <div class="panel">
            <h2>Шифрование</h2>
            <textarea id="plaintext" placeholder="Введите текст..."></textarea>
            <button id="encrypt-btn">Зашифровать</button>
            <div id="encrypted-result"></div>
        </div>
        
        <div class="panel">
            <h2>Дешифрование</h2>
            <textarea id="ciphertext" placeholder="Введите текст..."></textarea>
            <button id="decrypt-btn">Дешифровать</button>
            <div id="decrypted-result"></div>
        </div>
    </div>
    
    <div class="panel">
        <h2>Настройки</h2>
        <div>
            <label for="alphabet">Алфавит (27 символов):</label>
            <input type="text" id="alphabet" value="ABCDEFGHIJKLMNOPQRSTUVWXYZ/" style="width: 100%">
        </div>
        <div style="margin-top: 10px;">
            <label for="key">Ключ:</label>
            <input type="text" id="key" value="SECRETKEY" style="width: 100%">
        </div>
        <button id="update-settings" style="margin-top: 10px;">Обновить</button>
        
        <div class="cube-display" id="cube-display"></div>
        <div id="status" class="status"></div>
    </div>

    <script>
        class TrifidCipher {
            constructor(alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ/", key = "") {
                this.setAlphabet(alphabet, key);
            }
            
            setAlphabet(alphabet, key) {
                if (alphabet.length !== 27) {
                    throw new Error("Алфавит должен содержать ровно 27 символов");
                }
                this.alphabet = alphabet;
                this.key = key;
                this.cube = this.generateCube();
            }
            
            generateCube() {
                let shuffledAlphabet = this.applyKeyToAlphabet();
                let cube = [[], [], []];
                
                for (let layer = 0; layer < 3; layer++) {
                    cube[layer] = [];
                    for (let row = 0; row < 3; row++) {
                        cube[layer][row] = [];
                        for (let col = 0; col < 3; col++) {
                            const index = layer * 9 + row * 3 + col;
                            cube[layer][row][col] = shuffledAlphabet[index];
                        }
                    }
                }
                return cube;
            }
            
            applyKeyToAlphabet() {
                const keyChars = [];
                for (let char of this.key.toUpperCase()) {
                    if (!keyChars.includes(char) && this.alphabet.includes(char)) {
                        keyChars.push(char);
                    }
                }
                
                const remainingChars = [];
                for (let char of this.alphabet) {
                    if (!keyChars.includes(char)) {
                        remainingChars.push(char);
                    }
                }
                
                return [...keyChars, ...remainingChars];
            }
            
            findCharCoordinates(char) {
                char = char.toUpperCase();
                if (!this.alphabet.includes(char)) {
                    char = this.alphabet[26]; // Используем последний символ для неизвестных
                }
                
                for (let layer = 0; layer < 3; layer++) {
                    for (let row = 0; row < 3; row++) {
                        for (let col = 0; col < 3; col++) {
                            if (this.cube[layer][row][col] === char) {
                                return [layer + 1, row + 1, col + 1];
                            }
                        }
                    }
                }
                return [3, 3, 3];
            }
            
            getCharFromCoordinates(layer, row, col) {
                return this.cube[layer - 1][row - 1][col - 1];
            }
            
            encrypt(text) {
                const prepared = this.prepareText(text);
                let result = "";
                
                for (let i = 0; i < prepared.length; i += 3) {
                    const trigram = prepared.substr(i, 3);
                    if (!trigram) continue;
                    
                    // Получаем координаты для всех букв триграммы
                    const coords = [];
                    for (let j = 0; j < trigram.length; j++) {
                        coords.push(...this.findCharCoordinates(trigram[j]));
                    }
                    
                    // ПРАВИЛЬНАЯ перегруппировка для шифрования
                    const regrouped = this.regroupForEncryption(coords);
                    
                    // Преобразуем обратно в буквы
                    for (let k = 0; k < regrouped.length; k += 3) {
                        const [l, r, c] = regrouped.slice(k, k + 3);
                        result += this.getCharFromCoordinates(l, r, c);
                    }
                }
                
                return result;
            }
            
            regroupForEncryption(coords) {
                // Разделяем координаты на слои, строки и столбцы
                const layers = [], rows = [], cols = [];
                for (let i = 0; i < coords.length; i += 3) {
                    layers.push(coords[i]);
                    rows.push(coords[i + 1]);
                    cols.push(coords[i + 2]);
                }
                
                // Объединяем: сначала все слои, затем строки, затем столбцы
                return [...layers, ...rows, ...cols];
            }
            
            decrypt(text) {
                const prepared = this.prepareText(text);
                let result = "";
                
                for (let i = 0; i < prepared.length; i += 3) {
                    const trigram = prepared.substr(i, 3);
                    if (!trigram) continue;
                    
                    const coords = [];
                    for (let j = 0; j < trigram.length; j++) {
                        coords.push(...this.findCharCoordinates(trigram[j]));
                    }
                    
                    // Обратная перегруппировка для дешифрования
                    const regrouped = this.regroupForDecryption(coords);
                    
                    for (let k = 0; k < regrouped.length; k += 3) {
                        const [l, r, c] = regrouped.slice(k, k + 3);
                        result += this.getCharFromCoordinates(l, r, c);
                    }
                }
                
                return result;
            }
            
            regroupForDecryption(coords) {
                const groupSize = coords.length / 3;
                const result = [];
                
                for (let i = 0; i < groupSize; i++) {
                    result.push(coords[i], coords[i + groupSize], coords[i + 2 * groupSize]);
                }
                
                return result;
            }
            
            prepareText(text) {
                let result = "";
                for (let char of text.toUpperCase()) {
                    if (this.alphabet.includes(char)) {
                        result += char;
                    } else if (char === " ") {
                        result += this.alphabet[26]; // Заменяем пробел
                    }
                }
                return result;
            }
            
            renderCube() {
                let html = "<h3>Текущий куб:</h3>";
                for (let layer = 0; layer < 3; layer++) {
                    html += `<div><strong>Слой ${layer + 1}:</strong><br>`;
                    for (let row = 0; row < 3; row++) {
                        html += this.cube[layer][row].join(" ") + "<br>";
                    }
                    html += "</div>";
                }
                return html;
            }
        }

        // Инициализация
        document.addEventListener('DOMContentLoaded', function() {
            const cipher = new TrifidCipher();
            
            function updateCubeDisplay() {
                document.getElementById('cube-display').innerHTML = cipher.renderCube();
            }
            
            document.getElementById('update-settings').addEventListener('click', function() {
                try {
                    cipher.setAlphabet(
                        document.getElementById('alphabet').value,
                        document.getElementById('key').value
                    );
                    updateCubeDisplay();
                    showStatus("Настройки обновлены", "success");
                } catch (e) {
                    showStatus("Ошибка: " + e.message, "error");
                }
            });
            
            document.getElementById('encrypt-btn').addEventListener('click', function() {
                try {
                    const result = cipher.encrypt(document.getElementById('plaintext').value);
                    document.getElementById('encrypted-result').textContent = result;
                    showStatus("Текст зашифрован", "success");
                } catch (e) {
                    showStatus("Ошибка шифрования: " + e.message, "error");
                }
            });
            
            document.getElementById('decrypt-btn').addEventListener('click', function() {
                try {
                    const result = cipher.decrypt(document.getElementById('ciphertext').value);
                    document.getElementById('decrypted-result').textContent = result;
                    showStatus("Текст дешифрован", "success");
                } catch (e) {
                    showStatus("Ошибка дешифрования: " + e.message, "error");
                }
            });
            
            function showStatus(message, type) {
                const el = document.getElementById('status');
                el.textContent = message;
                el.className = "status " + type;
            }
            
            // Первоначальная отрисовка
            updateCubeDisplay();
        });
    </script>
</body>
</html>
