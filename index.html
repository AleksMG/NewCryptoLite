<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Trifid Cipher</title>
    <style>
        :root {
            --primary-color: #4285f4;
            --secondary-color: #34a853;
            --error-color: #ea4335;
            --warning-color: #fbbc05;
            --light-gray: #f5f5f5;
            --dark-gray: #333;
            --border-radius: 6px;
            --box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            color: var(--dark-gray);
            background-color: #f9f9f9;
        }
        
        h1, h2, h3 {
            color: var(--primary-color);
        }
        
        .container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        
        .panel {
            flex: 1;
            min-width: 300px;
            background: white;
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: var(--box-shadow);
        }
        
        textarea {
            width: 100%;
            min-height: 100px;
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            font-family: inherit;
            resize: vertical;
        }
        
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #3367d6;
        }
        
        .btn-secondary {
            background-color: var(--secondary-color);
        }
        
        .btn-secondary:hover {
            background-color: #2d9249;
        }
        
        input[type="text"], select {
            width: 100%;
            padding: 8px 12px;
            margin: 8px 0 15px;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
        }
        
        .result-box {
            min-height: 50px;
            padding: 10px;
            background-color: var(--light-gray);
            border-radius: var(--border-radius);
            margin-top: 10px;
            word-break: break-word;
        }
        
        .status {
            margin-top: 15px;
            padding: 12px;
            border-radius: var(--border-radius);
        }
        
        .success {
            background-color: #e6f4ea;
            color: var(--secondary-color);
        }
        
        .error {
            background-color: #fce8e6;
            color: var(--error-color);
        }
        
        .warning {
            background-color: #fff8e1;
            color: #f57c00;
        }
        
        .cube-display {
            margin-top: 20px;
            font-family: monospace;
            background-color: var(--light-gray);
            padding: 15px;
            border-radius: var(--border-radius);
        }
        
        .cube-layer {
            margin-bottom: 15px;
        }
        
        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .setting-group {
            margin-bottom: 15px;
            position: relative;
        }
        
        .char-counter {
            position: absolute;
            right: 10px;
            top: 35px;
            font-size: 0.8em;
            color: #666;
        }
        
        .highlight {
            background-color: #e8f0fe;
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .panel {
                min-width: auto;
            }
        }
    </style>
</head>
<body>
    <h1>Enhanced Trifid Cipher</h1>
    
    <div class="container">
        <div class="panel">
            <h2>Encryption</h2>
            <textarea id="plaintext" placeholder="Enter text to encrypt..."></textarea>
            <button id="encrypt-btn" class="btn-secondary">Encrypt</button>
            <h3>Result:</h3>
            <div id="encrypted-result" class="result-box"></div>
        </div>
        
        <div class="panel">
            <h2>Decryption</h2>
            <textarea id="ciphertext" placeholder="Enter text to decrypt..."></textarea>
            <button id="decrypt-btn" class="btn-secondary">Decrypt</button>
            <h3>Result:</h3>
            <div id="decrypted-result" class="result-box"></div>
        </div>
    </div>
    
    <div class="panel">
        <h2>Settings</h2>
        
        <div class="settings-grid">
            <div class="setting-group">
                <label for="cube-size">Cube Size:</label>
                <select id="cube-size">
                    <option value="3">3×3×3 (27 characters)</option>
                    <option value="4">4×4×4 (64 characters)</option>
                </select>
            </div>
            
            <div class="setting-group">
                <label for="key">Key:</label>
                <input type="text" id="key" value="SECRETKEY">
            </div>
            
            <div class="setting-group">
                <label for="space-char">Space Replacement:</label>
                <input type="text" id="space-char" value="/" maxlength="1">
            </div>
        </div>
        
        <div class="setting-group">
            <label for="alphabet">Alphabet (must match cube size):</label>
            <input type="text" id="alphabet" value="ABCDEFGHIJKLMNOPQRSTUVWXYZ/">
            <div id="char-counter" class="char-counter">27/27</div>
            <small id="alphabet-info" class="highlight">27 characters required for 3×3×3 cube</small>
        </div>
        
        <button id="update-settings">Update Settings</button>
        <button id="clean-alphabet" style="margin-left: 10px;">Clean Alphabet</button>
        
        <div id="status" class="status"></div>
        
        <div class="cube-display" id="cube-display"></div>
    </div>

    <script>
        class EnhancedTrifidCipher {
            constructor(cubeSize = 3, alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ/", key = "", spaceChar = "/") {
                this.cubeSize = cubeSize;
                this.spaceChar = spaceChar;
                this.setAlphabet(alphabet, key);
            }
            
            setAlphabet(alphabet, key) {
                // Clean the alphabet: remove duplicates, spaces, and make uppercase
                let cleanAlphabet = this.cleanString(alphabet);
                const requiredLength = this.cubeSize * this.cubeSize * this.cubeSize;
                
                if (cleanAlphabet.length !== requiredLength) {
                    throw new Error(`Alphabet must contain exactly ${requiredLength} unique characters for ${this.cubeSize}×${this.cubeSize}×${this.cubeSize} cube (got ${cleanAlphabet.length})`);
                }
                
                this.alphabet = cleanAlphabet;
                this.key = key;
                this.cube = this.generateCube();
            }
            
            cleanString(str) {
                // Remove all whitespace, convert to uppercase, and remove duplicates
                return [...new Set(str.toUpperCase().replace(/\s/g, ''))].join('');
            }
            
            generateCube() {
                let shuffledAlphabet = this.applyKeyToAlphabet();
                let cube = [];
                
                for (let layer = 0; layer < this.cubeSize; layer++) {
                    cube[layer] = [];
                    for (let row = 0; row < this.cubeSize; row++) {
                        cube[layer][row] = [];
                        for (let col = 0; col < this.cubeSize; col++) {
                            const index = layer * this.cubeSize * this.cubeSize + row * this.cubeSize + col;
                            cube[layer][row][col] = shuffledAlphabet[index] || '?';
                        }
                    }
                }
                return cube;
            }
            
            applyKeyToAlphabet() {
                const cleanKey = this.cleanString(this.key);
                const keyChars = [];
                
                // Add key characters first, removing duplicates
                for (let char of cleanKey) {
                    if (!keyChars.includes(char) && this.alphabet.includes(char)) {
                        keyChars.push(char);
                    }
                }
                
                // Add remaining alphabet characters
                const remainingChars = [];
                for (let char of this.alphabet) {
                    if (!keyChars.includes(char)) {
                        remainingChars.push(char);
                    }
                }
                
                return [...keyChars, ...remainingChars];
            }
            
            findCharCoordinates(char) {
                char = char.toUpperCase();
                
                // Handle space replacement
                if (char === ' ' || char === this.spaceChar) {
                    char = this.spaceChar;
                }
                
                if (!this.alphabet.includes(char)) {
                    // Use the last character as fallback
                    return [this.cubeSize, this.cubeSize, this.cubeSize];
                }
                
                for (let layer = 0; layer < this.cubeSize; layer++) {
                    for (let row = 0; row < this.cubeSize; row++) {
                        for (let col = 0; col < this.cubeSize; col++) {
                            if (this.cube[layer][row][col] === char) {
                                return [layer + 1, row + 1, col + 1];
                            }
                        }
                    }
                }
                
                return [this.cubeSize, this.cubeSize, this.cubeSize];
            }
            
            getCharFromCoordinates(layer, row, col) {
                // Ensure coordinates are within bounds
                layer = Math.max(1, Math.min(layer, this.cubeSize));
                row = Math.max(1, Math.min(row, this.cubeSize));
                col = Math.max(1, Math.min(col, this.cubeSize));
                
                return this.cube[layer - 1][row - 1][col - 1];
            }
            
            encrypt(text) {
                const prepared = this.prepareText(text);
                let result = "";
                
                // Process in groups of cubeSize characters
                for (let i = 0; i < prepared.length; i += this.cubeSize) {
                    const group = prepared.substr(i, this.cubeSize);
                    if (!group) continue;
                    
                    // Get coordinates for all characters in the group
                    const coords = [];
                    for (let j = 0; j < group.length; j++) {
                        coords.push(...this.findCharCoordinates(group[j]));
                    }
                    
                    // Regroup for encryption
                    const regrouped = this.regroupForEncryption(coords);
                    
                    // Convert back to characters
                    for (let k = 0; k < regrouped.length; k += 3) {
                        const [l, r, c] = regrouped.slice(k, k + 3);
                        result += this.getCharFromCoordinates(l, r, c);
                    }
                }
                
                return result;
            }
            
            regroupForEncryption(coords) {
                const groupSize = coords.length / 3;
                const layers = [], rows = [], cols = [];
                
                for (let i = 0; i < coords.length; i += 3) {
                    layers.push(coords[i]);
                    rows.push(coords[i + 1]);
                    cols.push(coords[i + 2]);
                }
                
                return [...layers, ...rows, ...cols];
            }
            
            decrypt(text) {
                const prepared = this.prepareText(text);
                let result = "";
                
                // Process in groups of cubeSize characters
                for (let i = 0; i < prepared.length; i += this.cubeSize) {
                    const group = prepared.substr(i, this.cubeSize);
                    if (!group) continue;
                    
                    const coords = [];
                    for (let j = 0; j < group.length; j++) {
                        coords.push(...this.findCharCoordinates(group[j]));
                    }
                    
                    // Regroup for decryption
                    const regrouped = this.regroupForDecryption(coords);
                    
                    // Convert back to characters
                    for (let k = 0; k < regrouped.length; k += 3) {
                        const [l, r, c] = regrouped.slice(k, k + 3);
                        result += this.getCharFromCoordinates(l, r, c);
                    }
                }
                
                return result;
            }
            
            regroupForDecryption(coords) {
                const groupSize = coords.length / 3;
                const result = [];
                
                for (let i = 0; i < groupSize; i++) {
                    result.push(
                        coords[i], 
                        coords[i + groupSize], 
                        coords[i + 2 * groupSize]
                    );
                }
                
                return result;
            }
            
            prepareText(text) {
                let result = "";
                const upperText = text.toUpperCase();
                
                for (let char of upperText) {
                    if (this.alphabet.includes(char)) {
                        result += char;
                    } else if (char === ' ') {
                        result += this.spaceChar;
                    }
                    // Skip characters not in alphabet
                }
                
                return result;
            }
            
            renderCube() {
                let html = "<h3>Current Cube:</h3>";
                
                for (let layer = 0; layer < this.cubeSize; layer++) {
                    html += `<div class="cube-layer"><strong>Layer ${layer + 1}:</strong><pre>`;
                    for (let row = 0; row < this.cubeSize; row++) {
                        html += this.cube[layer][row].join(' ') + '\n';
                    }
                    html += "</pre></div>";
                }
                
                return html;
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            const cubeSizeSelect = document.getElementById('cube-size');
            const alphabetInput = document.getElementById('alphabet');
            const keyInput = document.getElementById('key');
            const spaceCharInput = document.getElementById('space-char');
            const alphabetInfo = document.getElementById('alphabet-info');
            const charCounter = document.getElementById('char-counter');
            const cleanAlphabetBtn = document.getElementById('clean-alphabet');
            
            // Default alphabet for 3×3×3 cube
            const defaultAlphabet3x3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ/";
            // Extended alphabet for 4×4×4 cube (letters + numbers + symbols)
            const defaultAlphabet4x4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{}|;':\",./<>?";
            
            let cipher = new EnhancedTrifidCipher(
                parseInt(cubeSizeSelect.value),
                defaultAlphabet3x3,
                keyInput.value,
                spaceCharInput.value
            );
            
            // Update character counter
            function updateCharCounter() {
                const currentLength = alphabetInput.value.length;
                const requiredLength = Math.pow(parseInt(cubeSizeSelect.value), 3);
                charCounter.textContent = `${currentLength}/${requiredLength}`;
                
                if (currentLength < requiredLength) {
                    charCounter.style.color = 'var(--error-color)';
                } else if (currentLength > requiredLength) {
                    charCounter.style.color = 'var(--warning-color)';
                } else {
                    charCounter.style.color = 'var(--secondary-color)';
                }
            }
            
            // Clean alphabet input
            function cleanAlphabet() {
                const cleaned = [...new Set(alphabetInput.value.toUpperCase().replace(/\s/g, ''))].join('');
                alphabetInput.value = cleaned;
                updateCharCounter();
            }
            
            // Update UI based on cube size selection
            function updateUIForCubeSize() {
                const size = parseInt(cubeSizeSelect.value);
                const requiredLength = size * size * size;
                
                alphabetInfo.textContent = `${requiredLength} characters required for ${size}×${size}×${size} cube`;
                
                // Set default alphabet when switching sizes
                if (size === 3) {
                    alphabetInput.value = defaultAlphabet3x3;
                } else {
                    alphabetInput.value = defaultAlphabet4x4.substring(0, requiredLength);
                }
                
                updateCharCounter();
            }
            
            // Update cube display
            function updateCubeDisplay() {
                document.getElementById('cube-display').innerHTML = cipher.renderCube();
            }
            
            // Show status message
            function showStatus(message, type = "success") {
                const el = document.getElementById('status');
                el.textContent = message;
                el.className = "status " + type;
                
                // Auto-hide success messages after 5 seconds
                if (type === "success") {
                    setTimeout(() => {
                        if (el.textContent === message) {
                            el.textContent = '';
                            el.className = "status";
                        }
                    }, 5000);
                }
            }
            
            // Event listeners
            cubeSizeSelect.addEventListener('change', function() {
                updateUIForCubeSize();
            });
            
            alphabetInput.addEventListener('input', function() {
                updateCharCounter();
            });
            
            cleanAlphabetBtn.addEventListener('click', function() {
                cleanAlphabet();
                showStatus("Alphabet cleaned (removed duplicates and spaces)", "success");
            });
            
            document.getElementById('update-settings').addEventListener('click', function() {
                try {
                    cipher = new EnhancedTrifidCipher(
                        parseInt(cubeSizeSelect.value),
                        alphabetInput.value,
                        keyInput.value,
                        spaceCharInput.value
                    );
                    updateCubeDisplay();
                    showStatus("Settings updated successfully", "success");
                } catch (e) {
                    showStatus("Error: " + e.message, "error");
                }
            });
            
            document.getElementById('encrypt-btn').addEventListener('click', function() {
                try {
                    const result = cipher.encrypt(document.getElementById('plaintext').value);
                    document.getElementById('encrypted-result').textContent = result;
                    showStatus("Text encrypted successfully", "success");
                } catch (e) {
                    showStatus("Encryption error: " + e.message, "error");
                }
            });
            
            document.getElementById('decrypt-btn').addEventListener('click', function() {
                try {
                    const result = cipher.decrypt(document.getElementById('ciphertext').value);
                    document.getElementById('decrypted-result').textContent = result;
                    showStatus("Text decrypted successfully", "success");
                } catch (e) {
                    showStatus("Decryption error: " + e.message, "error");
                }
            });
            
            // Initialize UI
            updateUIForCubeSize();
            updateCharCounter();
            updateCubeDisplay();
        });
    </script>
</body>
</html>
