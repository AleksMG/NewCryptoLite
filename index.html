<!DOCTYPE html>
<html>
<head>
    <title>GraphLock Encryption Fixed</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        textarea { width: 100%; height: 100px; margin: 10px 0; }
        button { padding: 10px 15px; margin: 5px; }
        .container { display: flex; gap: 20px; }
        .box { flex: 1; border: 1px solid #ddd; padding: 15px; }
        .status { padding: 10px; margin-top: 10px; }
        .valid { background: #d4edda; color: #155724; }
        .invalid { background: #f8d7da; color: #721c24; }
    </style>
</head>
<body>
    <h1>Fixed GraphLock Encryption</h1>
    
    <div class="container">
        <div class="box">
            <h2>Encryption</h2>
            <textarea id="plaintext" placeholder="Enter text here...">Sample secret message</textarea>
            <button onclick="encrypt()">Encrypt</button>
            <h3>Encrypted Data (JSON):</h3>
            <textarea id="ciphertext" readonly></textarea>
            <button onclick="copyToDecrypt()">Copy to Decryption</button>
        </div>
        
        <div class="box">
            <h2>Decryption</h2>
            <textarea id="encryptedInput" placeholder="Paste encrypted JSON here..."></textarea>
            <button onclick="decrypt()">Decrypt</button>
            <h3>Decrypted Text:</h3>
            <textarea id="decrypted" readonly></textarea>
            <div id="decryptStatus" class="status">Waiting for decryption...</div>
        </div>
    </div>
    
    <div class="box">
        <h2>Proof Verification</h2>
        <button onclick="verifyProof()">Verify Proof</button>
        <div id="proofStatus" class="status">Proof not verified yet</div>
    </div>

    <script>
        // Fixed implementation
        
        // 1. Key and graph management
        let secret = {
            baseGraph: null,
            encryptedData: null
        };
        
        // 2. Generate a random graph
        function generateGraph(size=16) {
            let graph = [];
            for (let i = 0; i < size; i++) {
                let row = [];
                for (let j = 0; j < size; j++) {
                    row.push(Math.random() > 0.7 ? 1 : 0); // 30% chance of connection
                }
                graph.push(row);
            }
            return graph;
        }
        
        // 3. Create isomorphic graph with proof
        function createIsomorphicGraph(originalGraph) {
            const size = originalGraph.length;
            
            // Create random permutation
            let perm = Array.from({length: size}, (_, i) => i);
            for (let i = size - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [perm[i], perm[j]] = [perm[j], perm[i]];
            }
            
            // Apply permutation
            let newGraph = Array(size).fill().map(() => Array(size).fill(0));
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    newGraph[perm[i]][perm[j]] = originalGraph[i][j];
                }
            }
            
            // Simple proof for demo
            const proof = {
                permutation: perm,
                hash: hashCode(JSON.stringify(perm))
            };
            
            return { graph: newGraph, proof };
        }
        
        // 4. Simple hash function
        function hashCode(s) {
            return s.split('').reduce((a, b) => {
                a = ((a << 5) - a) + b.charCodeAt(0);
                return a & a;
            }, 0).toString(16);
        }
        
        // 5. Encode text into graph
        function encodeText(graph, text) {
            const encoder = new TextEncoder();
            const data = encoder.encode(text);
            let newGraph = JSON.parse(JSON.stringify(graph));
            
            // Simple encoding: modify graph edges based on text bytes
            for (let i = 0; i < data.length; i++) {
                const row = i % newGraph.length;
                const col = (i + 5) % newGraph[0].length;
                newGraph[row][col] = (newGraph[row][col] + data[i]) % 256;
            }
            
            return newGraph;
        }
        
        // 6. Decode text from graph
        function decodeText(originalGraph, modifiedGraph) {
            let bytes = [];
            const maxLength = originalGraph.length * originalGraph[0].length;
            
            for (let i = 0; i < maxLength; i++) {
                const row = i % originalGraph.length;
                const col = (i + 5) % originalGraph[0].length;
                
                // Calculate the difference
                const diff = (modifiedGraph[row][col] - originalGraph[row][col] + 256) % 256;
                
                // Stop at zero byte (simplification)
                if (diff === 0 && i > 0) break;
                
                bytes.push(diff);
            }
            
            return new TextDecoder().decode(new Uint8Array(bytes));
        }
        
        // 7. Main encryption function
        function encrypt() {
            const text = document.getElementById('plaintext').value;
            if (!text) return;
            
            // Generate base graph
            secret.baseGraph = generateGraph();
            
            // Create isomorphic version
            const { graph: encryptedGraph, proof } = createIsomorphicGraph(secret.baseGraph);
            
            // Encode text
            const textGraph = encodeText(encryptedGraph, text);
            
            // Prepare output
            const output = {
                graph: textGraph,
                proof: proof,
                timestamp: new Date().toISOString()
            };
            
            document.getElementById('ciphertext').value = JSON.stringify(output, null, 2);
            secret.encryptedData = output;
        }
        
        // 8. Main decryption function
        function decrypt() {
            const input = document.getElementById('encryptedInput').value;
            if (!input) return;
            
            try {
                const data = JSON.parse(input);
                
                if (!secret.baseGraph) {
                    document.getElementById('decryptStatus').textContent = "Error: No base graph available";
                    document.getElementById('decryptStatus').className = "status invalid";
                    return;
                }
                
                const decrypted = decodeText(secret.baseGraph, data.graph);
                document.getElementById('decrypted').value = decrypted;
                document.getElementById('decryptStatus').textContent = "Decryption successful!";
                document.getElementById('decryptStatus').className = "status valid";
                
                // Store for proof verification
                secret.encryptedData = data;
                
            } catch (e) {
                document.getElementById('decryptStatus').textContent = "Error: Invalid encrypted data";
                document.getElementById('decryptStatus').className = "status invalid";
            }
        }
        
        // 9. Proof verification
        function verifyProof() {
            if (!secret.encryptedData || !secret.baseGraph) {
                document.getElementById('proofStatus').textContent = "No data to verify";
                document.getElementById('proofStatus').className = "status invalid";
                return;
            }
            
            const { proof, graph: encryptedGraph } = secret.encryptedData;
            const baseGraph = secret.baseGraph;
            let isValid = true;
            
            // Verify the permutation
            for (let i = 0; i < baseGraph.length && isValid; i++) {
                for (let j = 0; j < baseGraph[i].length; j++) {
                    if (encryptedGraph[proof.permutation[i]][proof.permutation[j]] !== baseGraph[i][j]) {
                        isValid = false;
                        break;
                    }
                }
            }
            
            // Verify hash
            const recomputedHash = hashCode(JSON.stringify(proof.permutation));
            isValid = isValid && (recomputedHash === proof.hash);
            
            if (isValid) {
                document.getElementById('proofStatus').textContent = "Proof is VALID";
                document.getElementById('proofStatus').className = "status valid";
            } else {
                document.getElementById('proofStatus').textContent = "Proof is INVALID";
                document.getElementById('proofStatus').className = "status invalid";
            }
        }
        
        // Helper function
        function copyToDecrypt() {
            document.getElementById('encryptedInput').value = document.getElementById('ciphertext').value;
        }
        
        // Initialize with sample graph
        window.onload = function() {
            secret.baseGraph = generateGraph();
        };
    </script>
</body>
</html>
