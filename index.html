<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Quantum Homophonic Cipher</title>
    <style>
        :root {
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --secondary: #7c3aed;
            --accent: #06d6a0;
            --error: #ef4444;
            --warning: #f59e0b;
            --success: #10b981;
            --background: #0f172a;
            --surface: #1e293b;
            --surface-alt: #334155;
            --text: #f1f5f9;
            --text-dim: #94a3b8;
            --border: #475569;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: var(--background);
            color: var(--text);
            font-family: 'Fira Code', monospace;
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: var(--surface);
            border-radius: 10px;
            border: 1px solid var(--border);
        }

        .control-panel {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .config-panel {
            background: var(--surface);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid var(--border);
        }

        .main-panel {
            background: var(--surface);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid var(--border);
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: var(--text-dim);
            font-size: 0.9rem;
        }

        .input-field {
            width: 100%;
            padding: 10px;
            background: var(--surface-alt);
            border: 1px solid var(--border);
            border-radius: 5px;
            color: var(--text);
            font-family: 'Fira Code', monospace;
        }

        textarea.input-field {
            min-height: 100px;
            resize: vertical;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .btn {
            padding: 10px 20px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Fira Code', monospace;
            margin: 5px;
        }

        .btn:hover {
            background: var(--primary-dark);
        }

        .output-area {
            background: var(--surface-alt);
            padding: 15px;
            border-radius: 5px;
            margin-top: 10px;
            min-height: 100px;
            border: 1px solid var(--border);
            white-space: pre-wrap;
            word-break: break-all;
        }

        .analysis-panel {
            background: var(--surface);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid var(--border);
            margin-top: 20px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat-card {
            background: var(--surface-alt);
            padding: 15px;
            border-radius: 5px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.4rem;
            font-weight: bold;
            color: var(--accent);
        }

        .mapping-visual {
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
        }

        .mapping-item {
            display: flex;
            justify-content: space-between;
            padding: 5px;
            border-bottom: 1px solid var(--border);
            font-size: 0.9rem;
        }

        .frequency-chart {
            display: flex;
            align-items: end;
            height: 100px;
            gap: 2px;
            margin-top: 10px;
        }

        .frequency-bar {
            flex: 1;
            background: var(--accent);
            min-height: 1px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Professional Quantum Homophonic Cipher</h1>
            <p>Полная реализация гомофонного шифра с CBC режимом и афинными преобразованиями</p>
        </div>

        <div class="control-panel">
            <div class="config-panel">
                <h3>Конфигурация шифра</h3>
                
                <div class="input-group">
                    <label class="input-label">Ключ шифрования:</label>
                    <input type="text" class="input-field" id="cryptoKey" value="quantum-key-256">
                </div>

                <div class="checkbox-group">
                    <input type="checkbox" id="cbcMode" checked>
                    <label for="cbcMode">CBC режим (цепочка блоков)</label>
                </div>

                <div class="checkbox-group">
                    <input type="checkbox" id="affineMode" checked>
                    <label for="affineMode">Афинные преобразования</label>
                </div>

                <div class="input-group">
                    <label class="input-label">Параметр A (афинный):</label>
                    <input type="number" class="input-field" id="affineA" value="5" min="1" max="25">
                </div>

                <div class="input-group">
                    <label class="input-label">Параметр B (афинный):</label>
                    <input type="number" class="input-field" id="affineB" value="7" min="0" max="25">
                </div>

                <div class="input-group">
                    <label class="input-label">Алфавит гомофонов:</label>
                    <textarea class="input-field" id="homophoneAlphabet">ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789ⴰⴱⴳⴷⴹⴻⴼⴽⵀⵂⵃⵄⵅⵆⵇⵈⵉⵊⵋⵌⵍⵎⵏⵐⵑⵒⵓⵔⵕⵖⵗⵘⵙⵚⵛⵜⵝⵞⵟⵠⵡⵢⵣⵤⵥⵦ</textarea>
                </div>

                <button class="btn" onclick="initializeCipher()">Инициализировать шифр</button>
                <button class="btn" onclick="analyzeSystem()">Анализ системы</button>
            </div>

            <div class="main-panel">
                <h3>Обработка текста</h3>
                
                <div class="input-group">
                    <label class="input-label">Исходный текст:</label>
                    <textarea class="input-field" id="plainText">QUANTUM HOMOPHONIC CIPHER DEMONSTRATION</textarea>
                </div>

                <button class="btn" onclick="encryptText()">Зашифровать</button>
                <button class="btn" onclick="decryptText()">Расшифровать</button>

                <div class="input-group">
                    <label class="input-label">Результат:</label>
                    <div class="output-area" id="outputResult"></div>
                </div>

                <div class="input-group">
                    <label class="input-label">Зашифрованный текст для расшифровки:</label>
                    <textarea class="input-field" id="cipherText"></textarea>
                </div>
            </div>
        </div>

        <div class="analysis-panel">
            <h3>Анализ и визуализация</h3>
            
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="entropyValue">0.00</div>
                    <div>Энтропия (бит/символ)</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="homophoneCount">0</div>
                    <div>Уникальных гомофонов</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="bigramCoverage">0%</div>
                    <div>Покрытие биграмм</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="securityLevel">0%</div>
                    <div>Уровень безопасности</div>
                </div>
            </div>

            <div class="mapping-visual" id="mappingVisual">
                <div>Маппинг биграмм на гомофоны будет отображен здесь</div>
            </div>

            <div class="input-group">
                <label class="input-label">Частотный анализ:</label>
                <div class="frequency-chart" id="frequencyChart"></div>
            </div>
        </div>
    </div>

    <script>
        class ProfessionalHomophonicCipher {
            constructor() {
                this.alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                this.homophoneAlphabet = '';
                this.sBox = new Map();
                this.reverseSBox = new Map();
                this.duplicates = new Set();
                this.config = {
                    cbcMode: true,
                    affineMode: true,
                    affineA: 5,
                    affineB: 7,
                    iv: 'AA'
                };
            }

            initialize(homophoneChars, key) {
                // Валидация и подготовка алфавита
                const uniqueChars = [...new Set(homophoneChars)].filter(c => c.trim() !== '');
                if (uniqueChars.length < 2) throw new Error('Алфавит слишком мал');
                
                this.homophoneAlphabet = uniqueChars.join('');
                this.generateSBox(key);
            }

            generateSBox(key) {
                this.sBox.clear();
                this.reverseSBox.clear();
                this.duplicates.clear();

                const bigrams = this.generateAllBigrams();
                const homophones = this.generateAllHomophones();
                
                // Ключе-зависимое перемешивание
                const shuffledHomophones = this.keyBasedShuffle(homophones, key);
                
                // Распределение гомофонов по биграммам
                this.distributeHomophones(bigrams, shuffledHomophones);
                this.buildReverseMapping();
            }

            generateAllBigrams() {
                const bigrams = [];
                for (let i = 0; i < this.alphabet.length; i++) {
                    for (let j = 0; j < this.alphabet.length; j++) {
                        bigrams.push(this.alphabet[i] + this.alphabet[j]);
                    }
                }
                return bigrams;
            }

            generateAllHomophones() {
                const homophones = [];
                const chars = this.homophoneAlphabet;
                for (let i = 0; i < chars.length; i++) {
                    for (let j = 0; j < chars.length; j++) {
                        homophones.push(chars[i] + chars[j]);
                    }
                }
                return homophones;
            }

            keyBasedShuffle(array, key) {
                // Детерминистичное перемешивание на основе ключа
                const seed = this.stringToSeed(key);
                const result = [...array];
                
                for (let i = result.length - 1; i > 0; i--) {
                    const j = this.pseudoRandom(seed + i) % (i + 1);
                    [result[i], result[j]] = [result[j], result[i]];
                }
                
                return result;
            }

            stringToSeed(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    hash = ((hash << 5) - hash) + str.charCodeAt(i);
                    hash |= 0;
                }
                return hash;
            }

            pseudoRandom(seed) {
                let x = Math.sin(seed++) * 10000;
                return Math.floor((x - Math.floor(x)) * 0xFFFFFFFF);
            }

            distributeHomophones(bigrams, homophones) {
                const totalHomophones = homophones.length;
                const totalBigrams = bigrams.length;
                const baseCount = Math.floor(totalHomophones / totalBigrams);
                const extra = totalHomophones % totalBigrams;

                let index = 0;
                for (let i = 0; i < totalBigrams; i++) {
                    const count = i < extra ? baseCount + 1 : baseCount;
                    this.sBox.set(bigrams[i], homophones.slice(index, index + count));
                    index += count;
                }
            }

            buildReverseMapping() {
                for (const [bigram, homophones] of this.sBox.entries()) {
                    for (const homophone of homophones) {
                        if (this.reverseSBox.has(homophone)) {
                            this.duplicates.add(homophone);
                        } else {
                            this.reverseSBox.set(homophone, bigram);
                        }
                    }
                }
                
                // Удаляем дубликаты из обратного маппинга
                for (const duplicate of this.duplicates) {
                    this.reverseSBox.delete(duplicate);
                }
            }

            encrypt(plaintext) {
                const processed = plaintext.toUpperCase().replace(/[^A-Z]/g, '');
                if (!processed) throw new Error('Нет текста для шифрования');

                let ciphertext = '';
                let previousBlock = this.config.iv;
                let position = 0;

                for (let i = 0; i < processed.length; i += 2) {
                    let bigram = processed.substr(i, 2);
                    if (bigram.length === 1) bigram += 'X';

                    // Применяем преобразования
                    let targetBigram = bigram;
                    
                    if (this.config.affineMode) {
                        targetBigram = this.applyAffine(targetBigram);
                    }
                    
                    if (this.config.cbcMode) {
                        targetBigram = this.applyCBC(targetBigram, previousBlock, position);
                    }

                    // Шифруем гомофонами
                    if (this.sBox.has(targetBigram)) {
                        const homophones = this.sBox.get(targetBigram);
                        const randomIndex = this.pseudoRandom(position) % homophones.length;
                        ciphertext += homophones[randomIndex];
                        previousBlock = targetBigram;
                    }
                    
                    position++;
                }

                return ciphertext;
            }

            decrypt(ciphertext) {
                if (ciphertext.length % 2 !== 0) throw new Error('Неверная длина шифротекста');

                let plaintext = '';
                let previousBlock = this.config.iv;
                let position = 0;

                for (let i = 0; i < ciphertext.length; i += 2) {
                    const homophone = ciphertext.substr(i, 2);
                    
                    if (this.duplicates.has(homophone)) {
                        throw new Error(`Гомофон ${homophone} является дубликатом`);
                    }
                    
                    if (!this.reverseSBox.has(homophone)) {
                        throw new Error(`Гомофон ${homophone} не найден`);
                    }

                    let bigram = this.reverseSBox.get(homophone);

                    // Обратные преобразования
                    if (this.config.cbcMode) {
                        bigram = this.reverseCBC(bigram, previousBlock, position);
                    }
                    
                    if (this.config.affineMode) {
                        bigram = this.reverseAffine(bigram);
                    }

                    plaintext += bigram;
                    previousBlock = bigram;
                    position++;
                }

                // Удаляем паддинг
                if (plaintext.endsWith('X')) {
                    plaintext = plaintext.slice(0, -1);
                }

                return plaintext;
            }

            applyAffine(bigram) {
                let result = '';
                for (const char of bigram) {
                    const x = this.alphabet.indexOf(char);
                    const y = (this.config.affineA * x + this.config.affineB) % 26;
                    result += this.alphabet[y];
                }
                return result;
            }

            reverseAffine(bigram) {
                // Находим обратный элемент для A mod 26
                let aInv = 0;
                for (let i = 0; i < 26; i++) {
                    if ((this.config.affineA * i) % 26 === 1) {
                        aInv = i;
                        break;
                    }
                }

                let result = '';
                for (const char of bigram) {
                    const y = this.alphabet.indexOf(char);
                    const x = (aInv * (y - this.config.affineB + 26)) % 26;
                    result += this.alphabet[x];
                }
                return result;
            }

            applyCBC(bigram, previousBlock, position) {
                let result = '';
                for (let i = 0; i < 2; i++) {
                    const current = this.alphabet.indexOf(bigram[i]);
                    const previous = this.alphabet.indexOf(previousBlock[i]);
                    const newIndex = (current + previous + position) % 26;
                    result += this.alphabet[newIndex];
                }
                return result;
            }

            reverseCBC(bigram, previousBlock, position) {
                let result = '';
                for (let i = 0; i < 2; i++) {
                    const current = this.alphabet.indexOf(bigram[i]);
                    const previous = this.alphabet.indexOf(previousBlock[i]);
                    const original = (current - previous - position + 78) % 26;
                    result += this.alphabet[original];
                }
                return result;
            }

            calculateEntropy(text) {
                if (!text) return 0;
                const freq = {};
                for (const char of text) {
                    freq[char] = (freq[char] || 0) + 1;
                }

                let entropy = 0;
                const len = text.length;
                for (const char in freq) {
                    const p = freq[char] / len;
                    entropy -= p * Math.log2(p);
                }
                return entropy;
            }

            getStatistics() {
                let minHomophones = Infinity;
                let maxHomophones = 0;
                let totalHomophones = 0;
                let uncovered = 0;

                for (const homophones of this.sBox.values()) {
                    const count = homophones.length;
                    if (count > 0) {
                        minHomophones = Math.min(minHomophones, count);
                        maxHomophones = Math.max(maxHomophones, count);
                        totalHomophones += count;
                    } else {
                        uncovered++;
                    }
                }

                const coverage = ((this.sBox.size - uncovered) / this.sBox.size) * 100;
                const uniformity = 1 - (maxHomophones - minHomophones) / (maxHomophones || 1);

                return {
                    totalBigrams: this.sBox.size,
                    totalHomophones: totalHomophones,
                    minPerBigram: minHomophones,
                    maxPerBigram: maxHomophones,
                    coverage: coverage,
                    uniformity: uniformity,
                    duplicates: this.duplicates.size
                };
            }
        }

        // Глобальные переменные
        let cipher = new ProfessionalHomophonicCipher();

        function initializeCipher() {
            try {
                const key = document.getElementById('cryptoKey').value;
                const homophones = document.getElementById('homophoneAlphabet').value;
                const affineA = parseInt(document.getElementById('affineA').value);
                const affineB = parseInt(document.getElementById('affineB').value);
                
                cipher.config.cbcMode = document.getElementById('cbcMode').checked;
                cipher.config.affineMode = document.getElementById('affineMode').checked;
                cipher.config.affineA = affineA;
                cipher.config.affineB = affineB;

                cipher.initialize(homophones, key);
                document.getElementById('outputResult').textContent = 'Шифр успешно инициализирован';
                updateVisualization();
            } catch (error) {
                document.getElementById('outputResult').textContent = 'Ошибка: ' + error.message;
            }
        }

        function encryptText() {
            try {
                const plaintext = document.getElementById('plainText').value;
                const ciphertext = cipher.encrypt(plaintext);
                document.getElementById('outputResult').textContent = ciphertext;
                document.getElementById('cipherText').value = ciphertext;
            } catch (error) {
                document.getElementById('outputResult').textContent = 'Ошибка шифрования: ' + error.message;
            }
        }

        function decryptText() {
            try {
                const ciphertext = document.getElementById('cipherText').value;
                const plaintext = cipher.decrypt(ciphertext);
                document.getElementById('outputResult').textContent = plaintext;
            } catch (error) {
                document.getElementById('outputResult').textContent = 'Ошибка расшифровки: ' + error.message;
            }
        }

        function analyzeSystem() {
            const stats = cipher.getStatistics();
            const entropy = cipher.calculateEntropy(cipher.homophoneAlphabet);
            
            document.getElementById('entropyValue').textContent = entropy.toFixed(2);
            document.getElementById('homophoneCount').textContent = stats.totalHomophones;
            document.getElementById('bigramCoverage').textContent = stats.coverage.toFixed(1) + '%';
            document.getElementById('securityLevel').textContent = Math.min(100, (stats.uniformity * 100)).toFixed(0) + '%';

            updateFrequencyChart();
        }

        function updateVisualization() {
            const visual = document.getElementById('mappingVisual');
            visual.innerHTML = '';
            
            let count = 0;
            for (const [bigram, homophones] of cipher.sBox.entries()) {
                if (count++ > 20) break; // Ограничиваем вывод
                
                const item = document.createElement('div');
                item.className = 'mapping-item';
                item.innerHTML = `<span>${bigram}</span> <span>→</span> <span>${homophones.slice(0, 3).join(', ')}${homophones.length > 3 ? '...' : ''}</span>`;
                visual.appendChild(item);
            }
        }

        function updateFrequencyChart() {
            const chart = document.getElementById('frequencyChart');
            chart.innerHTML = '';
            
            // Простой частотный анализ
            const text = document.getElementById('plainText').value.toUpperCase();
            const freq = {};
            for (const char of text) {
                if (char >= 'A' && char <= 'Z') {
                    freq[char] = (freq[char] || 0) + 1;
                }
            }
            
            const maxFreq = Math.max(...Object.values(freq));
            for (let i = 0; i < 26; i++) {
                const char = String.fromCharCode(65 + i);
                const frequency = freq[char] || 0;
                const height = (frequency / maxFreq) * 100;
                
                const bar = document.createElement('div');
                bar.className = 'frequency-bar';
                bar.style.height = height + 'px';
                bar.title = `${char}: ${frequency}`;
                chart.appendChild(bar);
            }
        }

        // Автоматическая инициализация при загрузке
        window.onload = function() {
            initializeCipher();
            analyzeSystem();
        };
    </script>
</body>
</html>
