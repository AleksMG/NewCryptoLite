<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Working Lattice Cipher</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background: #f0f8ff;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h2 {
            color: #2c3e50;
            text-align: center;
        }
        .input-group {
            margin: 15px 0;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input, textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #3498db;
            border-radius: 5px;
            font-family: inherit;
        }
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px;
            width: 100%;
            margin: 5px 0;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        button:hover {
            background: #2980b9;
        }
        #result {
            margin-top: 20px;
            padding: 15px;
            border-radius: 5px;
            background: #eaf7ff;
        }
        .error {
            background: #ffecec;
            border-left: 4px solid #e74c3c;
            padding: 10px;
        }
        .success {
            background: #e8f7e8;
            border-left: 4px solid #2ecc71;
            padding: 10px;
        }
        .lattice {
            margin: 15px 0;
            padding: 10px;
            background: #f9f9f9;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>Lattice Cipher (Working Version)</h2>
        
        <div class="input-group">
            <label>Key (A-Z only):</label>
            <input type="text" id="key" value="LATTICE">
        </div>
        
        <div class="input-group">
            <label>Message:</label>
            <textarea id="message" rows="4">BLVMNQW</textarea>
        </div>
        
        <button onclick="encrypt()">Encrypt</button>
        <button onclick="decrypt()">Decrypt</button>
        
        <div id="result"></div>
        <div id="lattice"></div>
    </div>

    <script>
        // Простой алфавит A-Z
        const ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        
        // Преобразование текста в числовой вектор (A=0, B=1, ..., Z=25)
        function textToVector(text) {
            const cleaned = text.toUpperCase().replace(/[^A-Z]/g, '');
            return cleaned.split('').map(char => ALPHABET.indexOf(char));
        }
        
        // Преобразование вектора в текст
        function vectorToText(vector) {
            return vector.map(num => ALPHABET[num]).join('');
        }
        
        // Генерация решетки (циклический сдвиг)
        function generateLattice(keyVector) {
            const size = keyVector.length;
            const lattice = [];
            
            for (let i = 0; i < size; i++) {
                const row = [];
                for (let j = 0; j < size; j++) {
                    row.push(keyVector[(j + i) % size]);
                }
                lattice.push(row);
            }
            
            return lattice;
        }
        
        // Отображение решетки в HTML
        function displayLattice(lattice) {
            const container = document.getElementById('lattice');
            container.innerHTML = '<h3>Lattice Matrix:</h3><pre>';
            
            lattice.forEach(row => {
                container.innerHTML += row.map(val => 
                    val.toString().padStart(2, ' ')
                ).join(' ') + '\n';
            });
            
            container.innerHTML += '</pre>';
        }
        
        // Шифрование: вектор * решетка
        function latticeEncrypt(message, key) {
            const msgVec = textToVector(message);
            const keyVec = textToVector(key);
            const lattice = generateLattice(keyVec);
            
            // Проверка длины
            if (msgVec.length % keyVec.length !== 0) {
                throw new Error("Message length must be multiple of key length");
            }
            
            // Применение решетки
            const result = [];
            for (let i = 0; i < msgVec.length; i += keyVec.length) {
                const block = msgVec.slice(i, i + keyVec.length);
                for (let j = 0; j < keyVec.length; j++) {
                    let sum = 0;
                    for (let k = 0; k < keyVec.length; k++) {
                        sum += block[k] * lattice[j][k];
                    }
                    result.push(sum % 26);
                }
            }
            
            displayLattice(lattice);
            return vectorToText(result);
        }
        
        // Дешифрование: обратные операции
        function latticeDecrypt(cipher, key) {
            const cipherVec = textToVector(cipher);
            const keyVec = textToVector(key);
            const lattice = generateLattice(keyVec);
            
            // Проверка длины
            if (cipherVec.length % keyVec.length !== 0) {
                throw new Error("Cipher length must be multiple of key length");
            }
            
            // Для дешифрования используем обратные операции
            const result = [];
            for (let i = 0; i < cipherVec.length; i += keyVec.length) {
                const block = cipherVec.slice(i, i + keyVec.length);
                for (let j = 0; j < keyVec.length; j++) {
                    let val = block[j];
                    for (let k = 0; k < j; k++) {
                        val -= result[result.length - keyVec.length + k] * lattice[j][k];
                    }
                    val = (val % 26 + 26) % 26;
                    result.push(val);
                }
            }
            
            displayLattice(lattice);
            return vectorToText(result);
        }
        
        // Общие функции для интерфейса
        function encrypt() {
            try {
                const key = document.getElementById('key').value;
                const message = document.getElementById('message').value;
                
                if (!key || !message) throw new Error("Key and message are required");
                
                const result = latticeEncrypt(message, key);
                document.getElementById('result').className = 'success';
                document.getElementById('result').innerHTML = `
                    <strong>Encrypted:</strong> ${result}
                `;
            } catch (e) {
                document.getElementById('result').className = 'error';
                document.getElementById('result').innerHTML = `<strong>Error:</strong> ${e.message}`;
            }
        }
        
        function decrypt() {
            try {
                const key = document.getElementById('key').value;
                const cipher = document.getElementById('message').value;
                
                if (!key || !cipher) throw new Error("Key and ciphertext are required");
                
                const result = latticeDecrypt(cipher, key);
                document.getElementById('result').className = 'success';
                document.getElementById('result').innerHTML = `
                    <strong>Decrypted:</strong> ${result}
                `;
            } catch (e) {
                document.getElementById('result').className = 'error';
                document.getElementById('result').innerHTML = `<strong>Error:</strong> ${e.message}`;
            }
        }
    </script>
</body>
</html>
