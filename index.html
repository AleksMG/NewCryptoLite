<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Homophonic Cipher | Professional Edition</title>
    <style>
        :root {
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --secondary: #7c3aed;
            --accent: #06d6a0;
            --error: #ef4444;
            --warning: #f59e0b;
            --success: #10b981;
            --background: #0f172a;
            --surface: #1e293b;
            --surface-alt: #334155;
            --text: #f1f5f9;
            --text-dim: #94a3b8;
            --border: #475569;
            --card-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.3);
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: var(--background);
            color: var(--text);
            font-family: 'Inter', 'Segoe UI', system-ui, sans-serif;
            line-height: 1.6;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Header Styles */
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 40px;
            background: linear-gradient(135deg, var(--surface) 0%, var(--surface-alt) 100%);
            border-radius: 20px;
            border: 1px solid var(--border);
            box-shadow: var(--card-shadow);
        }

        .header h1 {
            font-size: 3rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent) 0%, var(--secondary) 100%);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 16px;
        }

        .header p {
            font-size: 1.2rem;
            color: var(--text-dim);
            max-width: 600px;
            margin: 0 auto;
        }

        /* Main Grid */
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 24px;
            margin-bottom: 24px;
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Panel Styles */
        .panel {
            background: var(--surface);
            border-radius: 16px;
            padding: 32px;
            border: 1px solid var(--border);
            box-shadow: var(--card-shadow);
        }

        .panel-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 24px;
            color: var(--accent);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .panel-title::before {
            content: "▶";
            font-size: 0.8em;
            color: var(--secondary);
        }

        /* Input Groups */
        .input-group {
            margin-bottom: 24px;
        }

        .input-label {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-dim);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .input-field {
            width: 100%;
            padding: 16px;
            background: var(--surface-alt);
            border: 2px solid var(--border);
            border-radius: 12px;
            color: var(--text);
            font-size: 1rem;
            transition: var(--transition);
        }

        .input-field:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        textarea.input-field {
            min-height: 120px;
            resize: vertical;
            font-family: 'Fira Code', 'Cascadia Code', monospace;
        }

        /* Button Styles */
        .btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 16px 24px;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: var(--transition);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px -5px rgba(37, 99, 235, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-group {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            margin: 24px 0;
        }

        /* Output Styles */
        .output-container {
            margin-top: 24px;
        }

        .output-label {
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-dim);
        }

        .output-content {
            background: var(--surface-alt);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--border);
            font-family: 'Fira Code', monospace;
            white-space: pre-wrap;
            word-break: break-all;
            min-height: 80px;
            max-height: 300px;
            overflow-y: auto;
        }

        /* Character Editor */
        .character-editor {
            background: var(--surface);
            border-radius: 16px;
            padding: 24px;
            border: 1px solid var(--border);
        }

        .editor-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 20px;
        }

        .alphabet-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(40px, 1fr));
            gap: 8px;
            margin-bottom: 20px;
            max-height: 200px;
            overflow-y: auto;
            padding: 16px;
            background: var(--surface-alt);
            border-radius: 12px;
        }

        .alphabet-char {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--background);
            border: 2px solid var(--border);
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
        }

        .alphabet-char:hover {
            border-color: var(--primary);
            transform: scale(1.1);
        }

        .alphabet-char.selected {
            border-color: var(--accent);
            background: var(--accent);
            color: var(--background);
        }

        .editor-controls {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-top: 20px;
        }

        .stat-card {
            background: var(--surface-alt);
            padding: 16px;
            border-radius: 12px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent);
        }

        .stat-label {
            font-size: 0.8rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Status Messages */
        .status {
            padding: 16px;
            border-radius: 12px;
            margin: 16px 0;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .status.success {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid var(--success);
            color: var(--success);
        }

        .status.error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid var(--error);
            color: var(--error);
        }

        .status.warning {
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid var(--warning);
            color: var(--warning);
        }

        .status.info {
            background: rgba(37, 99, 235, 0.1);
            border: 1px solid var(--primary);
            color: var(--primary);
        }

        /* Toggle Switch */
        .toggle {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--surface-alt);
            transition: var(--transition);
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 4px;
            bottom: 4px;
            background: var(--text);
            transition: var(--transition);
            border-radius: 50%;
        }

        input:checked + .slider {
            background: var(--primary);
        }

        input:checked + .slider:before {
            transform: translateX(24px);
        }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 6px;
            background: var(--surface-alt);
            border-radius: 3px;
            overflow: hidden;
            margin: 16px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--secondary));
            transition: width 0.3s ease;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .header {
                padding: 24px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .panel {
                padding: 24px;
            }
            
            .btn-group {
                flex-direction: column;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>QUANTUM HOMOPHONIC CIPHER</h1>
            <p>Advanced cryptographic system with customizable character sets and real-time entropy analysis</p>
        </header>

        <div class="main-grid">
            <div class="crypto-panels">
                <div class="panel">
                    <h2 class="panel-title">Cryptographic Configuration</h2>
                    
                    <div class="input-group">
                        <label class="input-label">
                            <span>Encryption Key</span>
                        </label>
                        <input type="password" class="input-field" id="crypto-key" 
                               value="quantum-secure-key-2024" placeholder="Enter strong encryption key">
                    </div>

                    <div class="toggle">
                        <label class="toggle-switch">
                            <input type="checkbox" id="cbc-mode" checked>
                            <span class="slider"></span>
                        </label>
                        <span>CBC Mode (Block Chaining)</span>
                    </div>

                    <div class="toggle">
                        <label class="toggle-switch">
                            <input type="checkbox" id="affine-mode" checked>
                            <span class="slider"></span>
                        </label>
                        <span>Affine Transformation</span>
                    </div>

                    <div class="btn-group">
                        <button class="btn" id="generate-btn">
                            <span>Generate S-Box</span>
                        </button>
                        <button class="btn" id="encrypt-btn">
                            <span>Encrypt Text</span>
                        </button>
                        <button class="btn" id="decrypt-btn">
                            <span>Decrypt Text</span>
                        </button>
                    </div>

                    <div class="progress-bar">
                        <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                    </div>

                    <div id="status" class="status info">
                        System ready - Configure your character set and generate S-Box
                    </div>
                </div>

                <div class="panel">
                    <h2 class="panel-title">Text Processing</h2>
                    
                    <div class="input-group">
                        <label class="input-label">Plaintext (A-Z only)</label>
                        <textarea class="input-field" id="plaintext" placeholder="Enter text to encrypt">QUANTUMCRYPTOGRAPHY</textarea>
                    </div>

                    <div class="input-group">
                        <label class="input-label">Ciphertext Output</label>
                        <div class="output-content" id="ciphertext-output">Encrypted text will appear here...</div>
                    </div>

                    <div class="input-group">
                        <label class="input-label">Ciphertext Input</label>
                        <textarea class="input-field" id="ciphertext" placeholder="Paste ciphertext to decrypt"></textarea>
                    </div>

                    <div class="input-group">
                        <label class="input-label">Decrypted Text</label>
                        <div class="output-content" id="decrypted-output">Decrypted text will appear here...</div>
                    </div>
                </div>
            </div>

            <div class="character-editor">
                <div class="editor-header">
                    <h2 class="panel-title">Character Set Editor</h2>
                </div>

                <div class="input-group">
                    <label class="input-label">Custom Character Set</label>
                    <textarea class="input-field" id="custom-chars" placeholder="Enter custom characters (duplicates will be removed)">ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789ⴰⴱⴳⴷⴹⴻⴼⴽⵀⵂⵃⵄⵅⵆⵇⵈⵉⵊⵋⵌⵍⵎⵏⵐⵑⵒⵓⵔⵕⵖⵗⵘⵙⵚⵛⵜⵝⵞⵟⵠⵡⵢⵣⵤⵥⵦ</textarea>
                </div>

                <div class="editor-controls">
                    <button class="btn" id="update-chars">
                        <span>Update Characters</span>
                    </button>
                    <button class="btn" id="reset-chars">
                        <span>Reset to Default</span>
                    </button>
                </div>

                <div class="alphabet-display" id="alphabet-display">
                    <!-- Characters will be rendered here -->
                </div>

                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="char-count">0</div>
                        <div class="stat-label">Characters</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="homophone-count">0</div>
                        <div class="stat-label">Homophones</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="entropy-value">0.00</div>
                        <div class="stat-label">Entropy/Char</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="bigram-ratio">0.00</div>
                        <div class="stat-label">Homophones/Bigram</div>
                    </div>
                </div>

                <div class="input-group">
                    <label class="input-label">Character Set Validation</label>
                    <div class="output-content" id="validation-output">No issues detected</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Professional Quantum Homophonic Cipher Implementation
        class QuantumHomophonicCipher {
            constructor() {
                this.alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                this.customChars = new Set();
                this.sBox = null;
                this.reverseSBox = null;
                this.currentKey = null;
                this.config = {
                    cbcMode: true,
                    affineMode: true,
                    affineA: 5,
                    affineB: 7
                };
                
                this.initializeDefaultChars();
            }

            initializeDefaultChars() {
                const defaultChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789ⴰⴱⴳⴷⴹⴻⴼⴽⵀⵂⵃⵄⵅⵆⵇⵈⵉⵊⵋⵌⵍⵎⵏⵐⵑⵒⵓⵔⵕⵖⵗⵘⵙⵚⵛⵜⵝⵞⵟⵠⵡⵢⵣⵤⵥⵦ';
                this.updateCustomChars(defaultChars);
            }

            updateCustomChars(charString) {
                // Remove duplicates and store as sorted array
                const uniqueChars = [...new Set(charString)].sort();
                this.customChars = new Set(uniqueChars);
                this.updateCharacterStats();
                return uniqueChars;
            }

            validateCharacterSet() {
                const issues = [];
                
                if (this.customChars.size < 2) {
                    issues.push('Minimum 2 characters required');
                }
                
                if (this.customChars.size > 1000) {
                    issues.push('Large character sets may impact performance');
                }

                // Check for visually similar characters
                const similarChars = this.findSimilarCharacters();
                if (similarChars.length > 0) {
                    issues.push(`Visually similar characters: ${similarChars.join(', ')}`);
                }

                return issues;
            }

            findSimilarCharacters() {
                const similarPairs = [];
                const chars = [...this.customChars];
                
                for (let i = 0; i < chars.length; i++) {
                    for (let j = i + 1; j < chars.length; j++) {
                        if (this.areCharactersSimilar(chars[i], chars[j])) {
                            similarPairs.push(`${chars[i]}↔${chars[j]}`);
                        }
                    }
                }
                
                return similarPairs;
            }

            areCharactersSimilar(char1, char2) {
                // Check for normalization equivalence
                if (char1.normalize('NFD').replace(/[\u0300-\u036f]/g, '') === 
                    char2.normalize('NFD').replace(/[\u0300-\u036f]/g, '')) {
                    return true;
                }
                
                // Check for case-insensitive equivalence
                if (char1.toLowerCase() === char2.toLowerCase()) {
                    return true;
                }
                
                return false;
            }

            updateCharacterStats() {
                const charCount = this.customChars.size;
                const homophoneCount = charCount * charCount;
                const maxEntropy = Math.log2(charCount);
                const bigramsCount = 26 * 26; // A-Z bigrams
                const homophonesPerBigram = homophoneCount / bigramsCount;

                return {
                    charCount,
                    homophoneCount,
                    maxEntropy: maxEntropy,
                    homophonesPerBigram
                };
            }

            async generateSBox(key, progressCallback = null) {
                if (!key) throw new Error('Encryption key required');
                if (this.customChars.size < 2) throw new Error('Character set too small');

                const chars = [...this.customChars];
                const allBigrams = this.generateAllBigrams();
                const allHomophones = this.generateAllHomophones(chars);

                if (progressCallback) progressCallback(20, 'Shuffling homophones...');

                // Cryptographically secure shuffling using key-based PRNG
                const shuffledHomophones = await this.keyBasedShuffle(allHomophones, key);
                if (progressCallback) progressCallback(60, 'Distributing homophones...');

                // Calculate optimal distribution
                const totalHomophones = shuffledHomophones.length;
                const totalBigrams = allBigrams.length;
                const baseCount = Math.floor(totalHomophones / totalBigrams);
                const extraCount = totalHomophones % totalBigrams;

                // Create S-Box with optimal distribution
                this.sBox = {};
                let homophoneIndex = 0;

                for (let i = 0; i < totalBigrams; i++) {
                    const count = i < extraCount ? baseCount + 1 : baseCount;
                    this.sBox[allBigrams[i]] = shuffledHomophones.slice(
                        homophoneIndex, 
                        homophoneIndex + count
                    );
                    homophoneIndex += count;
                }

                this.reverseSBox = this.createReverseSBox();
                this.currentKey = key;

                if (progressCallback) progressCallback(100, 'S-Box generated successfully');
                return true;
            }

            generateAllBigrams() {
                const bigrams = [];
                for (let i = 0; i < this.alphabet.length; i++) {
                    for (let j = 0; j < this.alphabet.length; j++) {
                        bigrams.push(this.alphabet[i] + this.alphabet[j]);
                    }
                }
                return bigrams;
            }

            generateAllHomophones(chars) {
                const homophones = [];
                for (let i = 0; i < chars.length; i++) {
                    for (let j = 0; j < chars.length; j++) {
                        homophones.push(chars[i] + chars[j]);
                    }
                }
                return homophones;
            }

            async keyBasedShuffle(array, key) {
                // Create a key-based deterministic random number generator
                const keyStream = await this.generateKeyStream(key, array.length * 4);
                const result = [...array];
                
                // Fisher-Yates shuffle with key-based randomness
                for (let i = result.length - 1; i > 0; i--) {
                    const j = this.getRandomInt(keyStream, i + 1);
                    [result[i], result[j]] = [result[j], result[i]];
                }
                
                return result;
            }

            async generateKeyStream(key, length) {
                const encoder = new TextEncoder();
                let keyStream = new Uint8Array(length);
                let position = 0;
                
                // Use PBKDF2-like approach to generate key stream
                for (let i = 0; position < length; i++) {
                    const data = encoder.encode(key + i.toString());
                    const hashBuffer = await crypto.subtle.digest('SHA-512', data);
                    const hashArray = new Uint8Array(hashBuffer);
                    
                    const copyLength = Math.min(hashArray.length, length - position);
                    keyStream.set(hashArray.subarray(0, copyLength), position);
                    position += copyLength;
                }
                
                return keyStream;
            }

            getRandomInt(keyStream, max) {
                // Use key stream bytes to generate random integer
                const randomValue = new DataView(keyStream.buffer).getUint32(0) % max;
                // Rotate key stream to ensure different values for next call
                const temp = keyStream[0];
                for (let i = 0; i < keyStream.length - 1; i++) {
                    keyStream[i] = keyStream[i + 1];
                }
                keyStream[keyStream.length - 1] = temp;
                
                return randomValue;
            }

            createReverseSBox() {
                const reverse = new Map();
                const duplicates = new Set();

                // Build reverse mapping with duplicate detection
                for (const [bigram, homophones] of Object.entries(this.sBox)) {
                    for (const homophone of homophones) {
                        if (reverse.has(homophone)) {
                            duplicates.add(homophone);
                        } else {
                            reverse.set(homophone, bigram);
                        }
                    }
                }

                // Remove duplicates from reverse mapping
                for (const duplicate of duplicates) {
                    reverse.delete(duplicate);
                }

                console.log(`Duplicate homophones detected: ${duplicates.size}`);
                return reverse;
            }

            async encrypt(plaintext) {
                if (!this.sBox) throw new Error('S-Box not generated');
                
                const processedText = plaintext.toUpperCase().replace(/[^A-Z]/g, '');
                if (!processedText) throw new Error('No valid text to encrypt');

                let ciphertext = '';
                let previousBlock = 'AA'; // Initialization vector
                let position = 0;

                for (let i = 0; i < processedText.length; i += 2) {
                    let bigram = processedText.substr(i, 2);
                    if (bigram.length === 1) bigram += 'X'; // Padding

                    // Apply transformations
                    let targetBigram = this.applyTransformations(bigram, previousBlock, position);
                    
                    // Get random homophone
                    if (this.sBox[targetBigram] && this.sBox[targetBigram].length > 0) {
                        const homophones = this.sBox[targetBigram];
                        const randomIndex = await this.getSecureRandom(homophones.length);
                        ciphertext += homophones[randomIndex];
                        previousBlock = targetBigram;
                    } else {
                        throw new Error(`No homophones available for bigram: ${targetBigram}`);
                    }
                    
                    position++;
                }

                return ciphertext;
            }

            async decrypt(ciphertext) {
                if (!this.reverseSBox) throw new Error('Reverse S-Box not generated');
                if (ciphertext.length % 2 !== 0) throw new Error('Ciphertext length must be even');
                
                let plaintext = '';
                let previousBlock = 'AA'; // Initialization vector
                let position = 0;

                for (let i = 0; i < ciphertext.length; i += 2) {
                    const homophone = ciphertext.substr(i, 2);
                    
                    if (!this.reverseSBox.has(homophone)) {
                        throw new Error(`Invalid homophone encountered: ${homophone}`);
                    }
                    
                    const targetBigram = this.reverseSBox.get(homophone);
                    const originalBigram = this.reverseTransformations(targetBigram, previousBlock, position);
                    
                    plaintext += originalBigram;
                    previousBlock = targetBigram;
                    position++;
                }

                // Remove padding if present
                if (plaintext.endsWith('X')) {
                    plaintext = plaintext.slice(0, -1);
                }
                
                return plaintext;
            }

            applyTransformations(bigram, previousBlock, position) {
                let result = bigram;

                if (this.config.affineMode) {
                    result = this.applyAffineTransformation(result);
                }

                if (this.config.cbcMode) {
                    result = this.applyCBCMode(result, previousBlock, position);
                }

                return result;
            }

            reverseTransformations(bigram, previousBlock, position) {
                let result = bigram;

                if (this.config.cbcMode) {
                    result = this.reverseCBCMode(result, previousBlock, position);
                }

                if (this.config.affineMode) {
                    result = this.reverseAffineTransformation(result);
                }

                return result;
            }

            applyCBCMode(bigram, previousBlock, position) {
                let result = '';
                for (let i = 0; i < 2; i++) {
                    const currentIdx = this.alphabet.indexOf(bigram[i]);
                    const prevIdx = this.alphabet.indexOf(previousBlock[i]);
                    const newIdx = (currentIdx + prevIdx + position) % 26;
                    result += this.alphabet[newIdx];
                }
                return result;
            }

            reverseCBCMode(bigram, previousBlock, position) {
                let result = '';
                for (let i = 0; i < 2; i++) {
                    const currentIdx = this.alphabet.indexOf(bigram[i]);
                    const prevIdx = this.alphabet.indexOf(previousBlock[i]);
                    // Reverse the CBC operation
                    let originalIdx = (currentIdx - prevIdx - position) % 26;
                    if (originalIdx < 0) originalIdx += 26;
                    result += this.alphabet[originalIdx];
                }
                return result;
            }

            applyAffineTransformation(bigram) {
                let result = '';
                for (const char of bigram) {
                    const x = this.alphabet.indexOf(char);
                    const y = (this.config.affineA * x + this.config.affineB) % 26;
                    result += this.alphabet[y];
                }
                return result;
            }

            reverseAffineTransformation(bigram) {
                // Calculate modular inverse of affineA
                let aInverse = 0;
                for (let i = 0; i < 26; i++) {
                    if ((this.config.affineA * i) % 26 === 1) {
                        aInverse = i;
                        break;
                    }
                }
                
                let result = '';
                for (const char of bigram) {
                    const y = this.alphabet.indexOf(char);
                    const x = (aInverse * (y - this.config.affineB + 26)) % 26;
                    result += this.alphabet[x];
                }
                return result;
            }

            async getSecureRandom(max) {
                const array = new Uint32Array(1);
                crypto.getRandomValues(array);
                return array[0] % max;
            }

            calculateEntropy(text) {
                if (!text) return 0;
                
                const frequencies = {};
                for (const char of text) {
                    frequencies[char] = (frequencies[char] || 0) + 1;
                }

                let entropy = 0;
                const len = text.length;
                
                for (const char in frequencies) {
                    const freq = frequencies[char] / len;
                    entropy -= freq * Math.log2(freq);
                }

                return entropy;
            }

            // Additional security validation
            validateSBox() {
                if (!this.sBox) return { valid: false, issues: ['S-Box not generated'] };
                
                const issues = [];
                let totalHomophones = 0;
                let emptyEntries = 0;
                
                for (const [bigram, homophones] of Object.entries(this.sBox)) {
                    if (homophones.length === 0) {
                        emptyEntries++;
                        issues.push(`No homophones for bigram: ${bigram}`);
                    }
                    totalHomophones += homophones.length;
                    
                    // Check for duplicates within the same bigram
                    const uniqueHomophones = new Set(homophones);
                    if (uniqueHomophones.size !== homophones.length) {
                        issues.push(`Duplicate homophones found for bigram: ${bigram}`);
                    }
                }
                
                // Check coverage
                const expectedBigrams = 26 * 26;
                const actualBigrams = Object.keys(this.sBox).length;
                
                if (actualBigrams !== expectedBigrams) {
                    issues.push(`S-Box coverage incomplete: ${actualBigrams}/${expectedBigrams} bigrams`);
                }
                
                return {
                    valid: issues.length === 0,
                    issues,
                    stats: {
                        totalHomophones,
                        emptyEntries,
                        coverage: `${actualBigrams}/${expectedBigrams}`
                    }
                };
            }
        }

        // Enhanced UI Controller with proper error handling
        class CipherUI {
            constructor() {
                this.cipher = new QuantumHomophonicCipher();
                this.initializeElements();
                this.setupEventListeners();
                this.updateDisplay();
            }

            initializeElements() {
                this.elements = {
                    // Inputs
                    cryptoKey: document.getElementById('crypto-key'),
                    plaintext: document.getElementById('plaintext'),
                    ciphertext: document.getElementById('ciphertext'),
                    customChars: document.getElementById('custom-chars'),
                    cbcMode: document.getElementById('cbc-mode'),
                    affineMode: document.getElementById('affine-mode'),
                    
                    // Outputs
                    ciphertextOutput: document.getElementById('ciphertext-output'),
                    decryptedOutput: document.getElementById('decrypted-output'),
                    validationOutput: document.getElementById('validation-output'),
                    alphabetDisplay: document.getElementById('alphabet-display'),
                    
                    // Stats
                    charCount: document.getElementById('char-count'),
                    homophoneCount: document.getElementById('homophone-count'),
                    entropyValue: document.getElementById('entropy-value'),
                    bigramRatio: document.getElementById('bigram-ratio'),
                    
                    // Controls
                    generateBtn: document.getElementById('generate-btn'),
                    encryptBtn: document.getElementById('encrypt-btn'),
                    decryptBtn: document.getElementById('decrypt-btn'),
                    updateCharsBtn: document.getElementById('update-chars'),
                    resetCharsBtn: document.getElementById('reset-chars'),
                    
                    // Progress
                    progressFill: document.getElementById('progress-fill'),
                    status: document.getElementById('status')
                };
            }

            setupEventListeners() {
                this.elements.generateBtn.addEventListener('click', () => this.generateSBox());
                this.elements.encryptBtn.addEventListener('click', () => this.encrypt());
                this.elements.decryptBtn.addEventListener('click', () => this.decrypt());
                this.elements.updateCharsBtn.addEventListener('click', () => this.updateCharacters());
                this.elements.resetCharsBtn.addEventListener('click', () => this.resetCharacters());
                
                this.elements.customChars.addEventListener('input', () => this.previewCharacters());
                this.elements.ciphertext.addEventListener('input', () => this.updateCiphertextStats());
                
                // Update cipher config when toggles change
                this.elements.cbcMode.addEventListener('change', () => {
                    this.cipher.config.cbcMode = this.elements.cbcMode.checked;
                });
                
                this.elements.affineMode.addEventListener('change', () => {
                    this.cipher.config.affineMode = this.elements.affineMode.checked;
                });
            }

            async generateSBox() {
                try {
                    this.setLoading('generate', true);
                    this.updateProgress(0, 'Initializing...');

                    await this.cipher.generateSBox(
                        this.elements.cryptoKey.value,
                        (progress, message) => {
                            this.updateProgress(progress, message);
                        }
                    );

                    // Validate S-Box after generation
                    const validation = this.cipher.validateSBox();
                    if (!validation.valid) {
                        console.warn('S-Box validation issues:', validation.issues);
                    }

                    this.showStatus('S-Box generated successfully', 'success');
                    this.updateStats();

                } catch (error) {
                    this.showStatus(`Error: ${error.message}`, 'error');
                    console.error('S-Box generation error:', error);
                } finally {
                    this.setLoading('generate', false);
                }
            }

            async encrypt() {
                try {
                    const plaintext = this.elements.plaintext.value;
                    if (!plaintext) throw new Error('Enter text to encrypt');
                    if (!this.cipher.sBox) throw new Error('Generate S-Box first');

                    this.setLoading('encrypt', true);
                    const ciphertext = await this.cipher.encrypt(plaintext);
                    
                    this.elements.ciphertextOutput.textContent = ciphertext;
                    this.elements.ciphertext.value = ciphertext;
                    this.showStatus('Text encrypted successfully', 'success');
                    this.updateCiphertextStats();

                } catch (error) {
                    this.showStatus(`Encryption error: ${error.message}`, 'error');
                    console.error('Encryption error:', error);
                } finally {
                    this.setLoading('encrypt', false);
                }
            }

            async decrypt() {
                try {
                    const ciphertext = this.elements.ciphertext.value;
                    if (!ciphertext) throw new Error('Enter ciphertext to decrypt');
                    if (!this.cipher.reverseSBox) throw new Error('Generate S-Box first');

                    this.setLoading('decrypt', true);
                    const plaintext = await this.cipher.decrypt(ciphertext);
                    
                    this.elements.decryptedOutput.textContent = plaintext;
                    this.showStatus('Text decrypted successfully', 'success');

                } catch (error) {
                    this.showStatus(`Decryption error: ${error.message}`, 'error');
                    console.error('Decryption error:', error);
                } finally {
                    this.setLoading('decrypt', false);
                }
            }

            updateCharacters() {
                try {
                    const charString = this.elements.customChars.value;
                    const uniqueChars = this.cipher.updateCustomChars(charString);
                    
                    this.elements.customChars.value = uniqueChars.join('');
                    this.updateDisplay();
                    this.showStatus('Character set updated', 'success');

                } catch (error) {
                    this.showStatus(`Error: ${error.message}`, 'error');
                }
            }

            resetCharacters() {
                this.cipher.initializeDefaultChars();
                this.elements.customChars.value = [...this.cipher.customChars].join('');
                this.updateDisplay();
                this.showStatus('Character set reset to default', 'success');
            }

            previewCharacters() {
                const charString = this.elements.customChars.value;
                const uniqueChars = [...new Set(charString)];
                this.renderAlphabetDisplay(uniqueChars);
            }

            renderAlphabetDisplay(chars) {
                const display = this.elements.alphabetDisplay;
                display.innerHTML = '';

                chars.forEach(char => {
                    const charElement = document.createElement('div');
                    charElement.className = 'alphabet-char';
                    charElement.textContent = char;
                    charElement.title = `Char: ${char}\nUnicode: U+${char.charCodeAt(0).toString(16).toUpperCase()}`;
                    display.appendChild(charElement);
                });
            }

            updateDisplay() {
                const stats = this.cipher.updateCharacterStats();
                const validationIssues = this.cipher.validateCharacterSet();

                // Update stats
                this.elements.charCount.textContent = stats.charCount;
                this.elements.homophoneCount.textContent = stats.homophoneCount.toLocaleString();
                this.elements.entropyValue.textContent = stats.maxEntropy.toFixed(2);
                this.elements.bigramRatio.textContent = stats.homophonesPerBigram.toFixed(1);

                // Update validation
                if (validationIssues.length > 0) {
                    this.elements.validationOutput.textContent = validationIssues.join('\n');
                    this.elements.validationOutput.className = 'output-content';
                    this.elements.validationOutput.style.color = 'var(--warning)';
                } else {
                    this.elements.validationOutput.textContent = 'No issues detected';
                    this.elements.validationOutput.className = 'output-content';
                    this.elements.validationOutput.style.color = 'var(--success)';
                }

                // Render alphabet
                this.renderAlphabetDisplay([...this.cipher.customChars]);
            }

            updateCiphertextStats() {
                const ciphertext = this.elements.ciphertext.value;
                const entropy = this.cipher.calculateEntropy(ciphertext);
                this.elements.entropyValue.textContent = entropy.toFixed(3);
            }

            updateProgress(percent, message) {
                this.elements.progressFill.style.width = `${percent}%`;
                if (message) {
                    this.showStatus(message, 'info');
                }
            }

            showStatus(message, type = 'info') {
                const status = this.elements.status;
                status.textContent = message;
                status.className = `status ${type}`;
            }

            setLoading(button, isLoading) {
                const btn = this.elements[`${button}Btn`];
                btn.disabled = isLoading;
                btn.style.opacity = isLoading ? 0.7 : 1;
            }
        }

        // Initialize application
        document.addEventListener('DOMContentLoaded', () => {
            new CipherUI();
        });
    </script>
</body>
</html>
