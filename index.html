<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Homophonic Cipher Pro</title>
    <style>
        :root {
            --primary: #1a365d; --secondary: #2d3748; --accent: #3182ce;
            --error: #e53e3e; --success: #38a169; --warning: #dd6b20;
            --background: #0f172a; --surface: #1e293b; --text: #f7fafc;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: var(--background); color: var(--text); 
            font-family: 'Courier New', monospace; padding: 20px;
        }
        .container { max-width: 1800px; margin: 0 auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background: var(--surface); }
        .grid { display: grid; grid-template-columns: 400px 1fr 400px; gap: 20px; }
        .panel { background: var(--surface); padding: 20px; border-radius: 10px; }
        .input-group { margin-bottom: 15px; }
        .input-label { display: block; margin-bottom: 5px; font-weight: bold; }
        .input-field { width: 100%; padding: 10px; background: #2d3748; border: 1px solid #4a5568; color: var(--text); }
        textarea.input-field { min-height: 120px; resize: vertical; font-family: inherit; }
        .btn { padding: 10px 15px; background: var(--accent); border: none; color: white; cursor: pointer; margin: 5px; }
        .output { background: #2d3748; padding: 15px; margin-top: 10px; min-height: 100px; border: 1px solid #4a5568; }
        .analysis { margin-top: 20px; }
        .stats { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin: 15px 0; }
        .stat { background: #2d3748; padding: 10px; text-align: center; }
        .mapping { max-height: 300px; overflow-y: auto; margin-top: 10px; }
        .mapping-item { display: flex; justify-content: space-between; padding: 5px; border-bottom: 1px solid #4a5568; font-size: 12px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>QUANTUM HOMOPHONIC CIPHER PROFESSIONAL</h1>
            <p>–ü–æ–ª–Ω–∞—è –Ω–µ–¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≥–æ–º–æ—Ñ–æ–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ —Å –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–º –∞–Ω–∞–ª–∏–∑–æ–º</p>
        </div>

        <div class="grid">
            <!-- –õ–µ–≤–∞—è –ø–∞–Ω–µ–ª—å - –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è -->
            <div class="panel">
                <h3>–ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –°–ò–°–¢–ï–ú–´</h3>
                
                <div class="input-group">
                    <label class="input-label">–ö–õ–Æ–ß –®–ò–§–†–û–í–ê–ù–ò–Ø:</label>
                    <input type="text" class="input-field" id="cryptoKey" value="quantum-secure-key-2024">
                </div>

                <div class="input-group">
                    <label class="input-label">–ê–õ–§–ê–í–ò–¢ –ò–°–¢–û–ß–ù–ò–ö–ê (A-Z):</label>
                    <input type="text" class="input-field" id="sourceAlphabet" value="ABCDEFGHIJKLMNOPQRSTUVWXYZ">
                </div>

                <div class="input-group">
                    <label class="input-label">–ê–õ–§–ê–í–ò–¢ –ì–û–ú–û–§–û–ù–û–í:</label>
                    <textarea class="input-field" id="homophoneAlphabet">ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789‚¥∞‚¥±‚¥≥‚¥∑‚¥π‚¥ª‚¥º‚¥Ω‚µÄ‚µÇ‚µÉ‚µÑ‚µÖ‚µÜ‚µá‚µà‚µâ‚µä‚µã‚µå‚µç‚µé‚µè‚µê‚µë‚µí‚µì‚µî‚µï‚µñ‚µó‚µò‚µô‚µö‚µõ‚µú‚µù‚µû‚µü‚µ†‚µ°‚µ¢‚µ£‚µ§‚µ•‚µ¶¬ß¬∂‚Ä¢¬™¬∫¬°¬ø‚Ç¨¬£¬•¬¢∆í¬±√ó√∑=<>‚àû‚âà~¬¨‚àß‚à®‚äï‚äó</textarea>
                </div>

                <div style="display: flex; gap: 10px;">
                    <button class="btn" onclick="initializeSystem()">üöÄ –ò–ù–ò–¶–ò–ê–õ–ò–ó–ò–†–û–í–ê–¢–¨</button>
                    <button class="btn" onclick="fullAnalysis()">üìä –ü–û–õ–ù–´–ô –ê–ù–ê–õ–ò–ó</button>
                </div>

                <div class="analysis">
                    <h4>–°–¢–ê–¢–£–° –°–ò–°–¢–ï–ú–´:</h4>
                    <div class="output" id="systemStatus">–û–∂–∏–¥–∞–Ω–∏–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏...</div>
                </div>
            </div>

            <!-- –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –ø–∞–Ω–µ–ª—å - –û–±—Ä–∞–±–æ—Ç–∫–∞ -->
            <div class="panel">
                <h3>–û–ë–†–ê–ë–û–¢–ö–ê –¢–ï–ö–°–¢–ê</h3>
                
                <div class="input-group">
                    <label class="input-label">–ò–°–•–û–î–ù–´–ô –¢–ï–ö–°–¢:</label>
                    <textarea class="input-field" id="plainText">QUANTUM HOMOPHONIC CIPHER DEMONSTRATION TEXT FOR SECURE COMMUNICATION</textarea>
                </div>

                <div style="display: flex; gap: 10px;">
                    <button class="btn" onclick="encryptText()">üîí –ó–ê–®–ò–§–†–û–í–ê–¢–¨</button>
                    <button class="btn" onclick="decryptText()">üîì –†–ê–°–®–ò–§–†–û–í–ê–¢–¨</button>
                    <button class="btn" onclick="testRoundTrip()">üîÑ –¢–ï–°–¢ –¶–ò–ö–õ–ê</button>
                </div>

                <div class="input-group">
                    <label class="input-label">–ó–ê–®–ò–§–†–û–í–ê–ù–ù–´–ô –¢–ï–ö–°–¢:</label>
                    <div class="output" id="cipherOutput"></div>
                </div>

                <div class="input-group">
                    <label class="input-label">–¢–ï–ö–°–¢ –î–õ–Ø –†–ê–°–®–ò–§–†–û–í–ö–ò:</label>
                    <textarea class="input-field" id="cipherInput"></textarea>
                </div>

                <div class="input-group">
                    <label class="input-label">–†–ê–°–®–ò–§–†–û–í–ê–ù–ù–´–ô –¢–ï–ö–°–¢:</label>
                    <div class="output" id="decryptedOutput"></div>
                </div>
            </div>

            <!-- –ü—Ä–∞–≤–∞—è –ø–∞–Ω–µ–ª—å - –ê–Ω–∞–ª–∏–∑ -->
            <div class="panel">
                <h3>–ê–ù–ê–õ–ò–ó –ò –í–ò–ó–£–ê–õ–ò–ó–ê–¶–ò–Ø</h3>
                
                <div class="stats">
                    <div class="stat">
                        <div style="font-size: 24px; color: #3182ce;" id="entropyValue">0.00</div>
                        <div>–≠–Ω—Ç—Ä–æ–ø–∏—è</div>
                    </div>
                    <div class="stat">
                        <div style="font-size: 24px; color: #38a169;" id="homophoneCount">0</div>
                        <div>–ì–æ–º–æ—Ñ–æ–Ω—ã</div>
                    </div>
                    <div class="stat">
                        <div style="font-size: 24px; color: #dd6b20;" id="bigramCount">0</div>
                        <div>–ë–∏–≥—Ä–∞–º–º—ã</div>
                    </div>
                    <div class="stat">
                        <div style="font-size: 24px; color: #e53e3e;" id="securityLevel">0%</div>
                        <div>–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å</div>
                    </div>
                </div>

                <div class="input-group">
                    <label class="input-label">–ß–ê–°–¢–û–¢–ù–´–ô –ê–ù–ê–õ–ò–ó:</label>
                    <div class="output" id="frequencyAnalysis"></div>
                </div>

                <div class="input-group">
                    <label class="input-label">–ú–ê–ü–ü–ò–ù–ì –ë–ò–ì–†–ê–ú–ú (–ø–µ—Ä–≤—ã–µ 50):</label>
                    <div class="mapping" id="mappingVisualization"></div>
                </div>

                <div class="input-group">
                    <label class="input-label">–î–ò–ê–ì–ù–û–°–¢–ò–ö–ê –°–ò–°–¢–ï–ú–´:</label>
                    <div class="output" id="systemDiagnostics"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class QuantumHomophonicCipherPro {
            constructor() {
                this.sourceAlphabet = '';
                this.homophoneAlphabet = '';
                this.sBox = new Map();
                this.reverseSBox = new Map();
                this.duplicates = new Set();
                this.nonDeterministicCache = new Map();
                this.config = {
                    cbcMode: true,
                    affineMode: true,
                    affineA: 7,
                    affineB: 3,
                    iv: 'AA'
                };
            }

            initialize(sourceAlphabet, homophoneAlphabet, key) {
                // –í–∞–ª–∏–¥–∞—Ü–∏—è –∏ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∞–ª—Ñ–∞–≤–∏—Ç–æ–≤
                this.sourceAlphabet = [...new Set(sourceAlphabet.toUpperCase())].join('');
                this.homophoneAlphabet = [...new Set(homophoneAlphabet)].join('');
                
                if (this.sourceAlphabet.length < 2) throw new Error('–ò—Å—Ö–æ–¥–Ω—ã–π –∞–ª—Ñ–∞–≤–∏—Ç —Å–ª–∏—à–∫–æ–º –º–∞–ª');
                if (this.homophoneAlphabet.length < 2) throw new Error('–ê–ª—Ñ–∞–≤–∏—Ç –≥–æ–º–æ—Ñ–æ–Ω–æ–≤ —Å–ª–∏—à–∫–æ–º –º–∞–ª');

                this.generateSBox(key);
                return this.getSystemStats();
            }

            generateSBox(key) {
                this.sBox.clear();
                this.reverseSBox.clear();
                this.duplicates.clear();
                this.nonDeterministicCache.clear();

                const bigrams = this.generateAllBigrams();
                const homophones = this.generateAllHomophones();
                
                // –ù–µ–¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–ª—é—á–∞ –∏ –≤—Ä–µ–º–µ–Ω–∏
                const shuffledHomophones = this.nonDeterministicShuffle(homophones, key);
                
                // –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å —É—á–µ—Ç–æ–º –Ω–µ–¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ—Å—Ç–∏
                this.distributeHomophonesNonDeterministic(bigrams, shuffledHomophones, key);
                this.buildReverseMapping();
            }

            generateAllBigrams() {
                const bigrams = [];
                for (let i = 0; i < this.sourceAlphabet.length; i++) {
                    for (let j = 0; j < this.sourceAlphabet.length; j++) {
                        bigrams.push(this.sourceAlphabet[i] + this.sourceAlphabet[j]);
                    }
                }
                return bigrams;
            }

            generateAllHomophones() {
                const homophones = [];
                for (let i = 0; i < this.homophoneAlphabet.length; i++) {
                    for (let j = 0; j < this.homophoneAlphabet.length; j++) {
                        homophones.push(this.homophoneAlphabet[i] + this.homophoneAlphabet[j]);
                    }
                }
                return homophones;
            }

            nonDeterministicShuffle(array, key) {
                // –ù–µ–¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏–µ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –≤—Ä–µ–º–µ–Ω–∏ –∏ —Å–ª—É—á–∞–π–Ω–æ—Å—Ç–∏
                const seed = this.createNonDeterministicSeed(key);
                const result = [...array];
                
                for (let i = result.length - 1; i > 0; i--) {
                    const j = this.nonDeterministicRandom(seed, i) % (i + 1);
                    [result[i], result[j]] = [result[j], result[i]];
                }
                
                return result;
            }

            createNonDeterministicSeed(key) {
                // –ö–æ–º–±–∏–Ω–∞—Ü–∏—è –∫–ª—é—á–∞, –≤—Ä–µ–º–µ–Ω–∏ –∏ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è –Ω–µ–¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ—Å—Ç–∏
                const timeFactor = Date.now() % 1000000;
                const randomFactor = Math.random() * 1000000;
                return this.hashString(key + timeFactor + randomFactor);
            }

            hashString(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    hash = ((hash << 5) - hash) + str.charCodeAt(i);
                    hash |= 0;
                }
                return Math.abs(hash);
            }

            nonDeterministicRandom(seed, index) {
                // –ù–µ–¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ì–ü–°–ß
                const x = Math.sin(seed + index + Math.random() * 1000) * 10000;
                return Math.floor((x - Math.floor(x)) * 0xFFFFFFFF);
            }

            distributeHomophonesNonDeterministic(bigrams, homophones, key) {
                const totalHomophones = homophones.length;
                const totalBigrams = bigrams.length;
                
                // –ù–µ–¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å –≤–∞—Ä—å–∏—Ä—É—é—â–∏–º—Å—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –≥–æ–º–æ—Ñ–æ–Ω–æ–≤ –Ω–∞ –±–∏–≥—Ä–∞–º–º—É
                let index = 0;
                const distributionSeed = this.createNonDeterministicSeed(key + 'distribution');
                
                for (let i = 0; i < totalBigrams; i++) {
                    // –ù–µ–¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≥–æ–º–æ—Ñ–æ–Ω–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–π –±–∏–≥—Ä–∞–º–º—ã
                    const minHomophones = 1;
                    const maxHomophones = Math.floor(totalHomophones / totalBigrams) * 3;
                    const count = minHomophones + this.nonDeterministicRandom(distributionSeed, i) % (maxHomophones - minHomophones + 1);
                    
                    const available = Math.min(count, totalHomophones - index);
                    if (available > 0) {
                        this.sBox.set(bigrams[i], homophones.slice(index, index + available));
                        index += available;
                    }
                }
            }

            buildReverseMapping() {
                for (const [bigram, homophones] of this.sBox.entries()) {
                    for (const homophone of homophones) {
                        if (this.reverseSBox.has(homophone)) {
                            this.duplicates.add(homophone);
                        } else {
                            this.reverseSBox.set(homophone, bigram);
                        }
                    }
                }
                
                // –£–¥–∞–ª—è–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã –¥–ª—è –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è –æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ—Å—Ç–∏ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏
                for (const duplicate of this.duplicates) {
                    this.reverseSBox.delete(duplicate);
                }
            }

            encrypt(plaintext) {
                const processed = plaintext.toUpperCase().replace(/[^A-Z]/g, '');
                if (!processed) throw new Error('–ù–µ—Ç —Ç–µ–∫—Å—Ç–∞ –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è');

                let ciphertext = '';
                let previousBlock = this.config.iv;
                let position = 0;

                for (let i = 0; i < processed.length; i += 2) {
                    let bigram = processed.substr(i, 2);
                    if (bigram.length === 1) bigram += 'X';

                    // –ü—Ä–∏–º–µ–Ω—è–µ–º –∞—Ñ–∏–Ω–Ω—ã–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è
                    let transformedBigram = bigram;
                    if (this.config.affineMode) {
                        transformedBigram = this.applyAffineTransformation(bigram);
                    }

                    // –ü—Ä–∏–º–µ–Ω—è–µ–º CBC —Ä–µ–∂–∏–º
                    if (this.config.cbcMode) {
                        transformedBigram = this.applyCBCMode(transformedBigram, previousBlock, position);
                    }

                    // –ù–µ–¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≤—ã–±–æ—Ä –≥–æ–º–æ—Ñ–æ–Ω–∞
                    if (this.sBox.has(transformedBigram)) {
                        const homophones = this.sBox.get(transformedBigram);
                        const randomIndex = this.nonDeterministicRandom(position + i, Date.now()) % homophones.length;
                        ciphertext += homophones[randomIndex];
                        previousBlock = transformedBigram;
                    }
                    
                    position++;
                }

                return ciphertext;
            }

            decrypt(ciphertext) {
                if (ciphertext.length % 2 !== 0) {
                    throw new Error('–î–ª–∏–Ω–∞ —à–∏—Ñ—Ä–æ—Ç–µ–∫—Å—Ç–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —á–µ—Ç–Ω–æ–π');
                }

                let plaintext = '';
                let previousBlock = this.config.iv;
                let position = 0;

                for (let i = 0; i < ciphertext.length; i += 2) {
                    const homophone = ciphertext.substr(i, 2);
                    
                    if (this.duplicates.has(homophone)) {
                        throw new Error(`–ì–æ–º–æ—Ñ–æ–Ω ${homophone} —è–≤–ª—è–µ—Ç—Å—è –¥—É–±–ª–∏–∫–∞—Ç–æ–º –∏ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω`);
                    }
                    
                    if (!this.reverseSBox.has(homophone)) {
                        throw new Error(`–ì–æ–º–æ—Ñ–æ–Ω ${homophone} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —Ç–∞–±–ª–∏—Ü–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è`);
                    }

                    let bigram = this.reverseSBox.get(homophone);

                    // –û–±—Ä–∞—Ç–Ω–æ–µ CBC –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ
                    if (this.config.cbcMode) {
                        bigram = this.reverseCBCMode(bigram, previousBlock, position);
                    }

                    // –û–±—Ä–∞—Ç–Ω–æ–µ –∞—Ñ–∏–Ω–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ
                    if (this.config.affineMode) {
                        bigram = this.reverseAffineTransformation(bigram);
                    }

                    plaintext += bigram;
                    previousBlock = bigram;
                    position++;
                }

                // –£–¥–∞–ª–µ–Ω–∏–µ –ø–∞–¥–¥–∏–Ω–≥–∞
                if (plaintext.endsWith('X')) {
                    plaintext = plaintext.slice(0, -1);
                }

                return plaintext;
            }

            applyAffineTransformation(bigram) {
                let result = '';
                for (const char of bigram) {
                    const x = this.sourceAlphabet.indexOf(char);
                    const y = (this.config.affineA * x + this.config.affineB) % this.sourceAlphabet.length;
                    result += this.sourceAlphabet[y];
                }
                return result;
            }

            reverseAffineTransformation(bigram) {
                // –ù–∞—Ö–æ–¥–∏–º –æ–±—Ä–∞—Ç–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç –¥–ª—è a mod m
                const m = this.sourceAlphabet.length;
                let aInv = 0;
                for (let i = 0; i < m; i++) {
                    if ((this.config.affineA * i) % m === 1) {
                        aInv = i;
                        break;
                    }
                }

                let result = '';
                for (const char of bigram) {
                    const y = this.sourceAlphabet.indexOf(char);
                    const x = (aInv * (y - this.config.affineB + m)) % m;
                    result += this.sourceAlphabet[x];
                }
                return result;
            }

            applyCBCMode(bigram, previousBlock, position) {
                let result = '';
                for (let i = 0; i < 2; i++) {
                    const current = this.sourceAlphabet.indexOf(bigram[i]);
                    const previous = this.sourceAlphabet.indexOf(previousBlock[i]);
                    const newIndex = (current + previous + position) % this.sourceAlphabet.length;
                    result += this.sourceAlphabet[newIndex];
                }
                return result;
            }

            reverseCBCMode(bigram, previousBlock, position) {
                let result = '';
                for (let i = 0; i < 2; i++) {
                    const current = this.sourceAlphabet.indexOf(bigram[i]);
                    const previous = this.sourceAlphabet.indexOf(previousBlock[i]);
                    const original = (current - previous - position + 3 * this.sourceAlphabet.length) % this.sourceAlphabet.length;
                    result += this.sourceAlphabet[original];
                }
                return result;
            }

            calculateEntropy(text) {
                if (!text) return 0;
                const freq = {};
                for (const char of text) {
                    freq[char] = (freq[char] || 0) + 1;
                }

                let entropy = 0;
                const len = text.length;
                for (const char in freq) {
                    const p = freq[char] / len;
                    entropy -= p * Math.log2(p);
                }
                return entropy;
            }

            getSystemStats() {
                let minHomophones = Infinity;
                let maxHomophones = 0;
                let totalHomophones = 0;
                let uncoveredBigrams = 0;

                for (const [bigram, homophones] of this.sBox.entries()) {
                    const count = homophones.length;
                    if (count > 0) {
                        minHomophones = Math.min(minHomophones, count);
                        maxHomophones = Math.max(maxHomophones, count);
                        totalHomophones += count;
                    } else {
                        uncoveredBigrams++;
                    }
                }

                const coverage = ((this.sBox.size - uncoveredBigrams) / this.sBox.size) * 100;
                const entropy = this.calculateEntropy(this.homophoneAlphabet);
                const securityLevel = Math.min(100, (coverage / 100) * (entropy / 8) * 100);

                return {
                    sourceAlphabetSize: this.sourceAlphabet.length,
                    homophoneAlphabetSize: this.homophoneAlphabet.length,
                    totalBigrams: this.sBox.size,
                    totalHomophones: totalHomophones,
                    minHomophonesPerBigram: minHomophones,
                    maxHomophonesPerBigram: maxHomophones,
                    coveragePercentage: coverage,
                    entropy: entropy,
                    securityLevel: securityLevel,
                    duplicateHomophones: this.duplicates.size,
                    uniqueMappings: this.reverseSBox.size
                };
            }

            frequencyAnalysis(text) {
                const freq = {};
                for (const char of text.toUpperCase()) {
                    if (this.sourceAlphabet.includes(char)) {
                        freq[char] = (freq[char] || 0) + 1;
                    }
                }
                return freq;
            }
        }

        // –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä —à–∏—Ñ—Ä–∞
        const cipher = new QuantumHomophonicCipherPro();

        function initializeSystem() {
            try {
                const key = document.getElementById('cryptoKey').value;
                const sourceAlphabet = document.getElementById('sourceAlphabet').value;
                const homophoneAlphabet = document.getElementById('homophoneAlphabet').value;

                const stats = cipher.initialize(sourceAlphabet, homophoneAlphabet, key);
                
                document.getElementById('systemStatus').textContent = 
                    `‚úÖ –°–∏—Å—Ç–µ–º–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞\n` +
                    `–ê–ª—Ñ–∞–≤–∏—Ç: ${stats.sourceAlphabetSize} —Å–∏–º–≤–æ–ª–æ–≤\n` +
                    `–ì–æ–º–æ—Ñ–æ–Ω—ã: ${stats.homophoneAlphabetSize} —Å–∏–º–≤–æ–ª–æ–≤\n` +
                    `–ë–∏–≥—Ä–∞–º–º—ã: ${stats.totalBigrams}\n` +
                    `–ü–æ–∫—Ä—ã—Ç–∏–µ: ${stats.coveragePercentage.toFixed(1)}%`;

                updateStatistics(stats);
                updateMappingVisualization();

            } catch (error) {
                document.getElementById('systemStatus').textContent = `‚ùå –û—à–∏–±–∫–∞: ${error.message}`;
            }
        }

        function encryptText() {
            try {
                const plaintext = document.getElementById('plainText').value;
                const ciphertext = cipher.encrypt(plaintext);
                
                document.getElementById('cipherOutput').textContent = ciphertext;
                document.getElementById('cipherInput').value = ciphertext;
                
                // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑ –ø–æ—Å–ª–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
                analyzeCiphertext(ciphertext);
                
            } catch (error) {
                document.getElementById('cipherOutput').textContent = `‚ùå –û—à–∏–±–∫–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ${error.message}`;
            }
        }

        function decryptText() {
            try {
                const ciphertext = document.getElementById('cipherInput').value;
                const plaintext = cipher.decrypt(ciphertext);
                document.getElementById('decryptedOutput').textContent = plaintext;
                
            } catch (error) {
                document.getElementById('decryptedOutput').textContent = `‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏: ${error.message}`;
            }
        }

        function testRoundTrip() {
            try {
                const originalText = document.getElementById('plainText').value;
                const ciphertext = cipher.encrypt(originalText);
                const decryptedText = cipher.decrypt(ciphertext);
                
                const success = originalText.toUpperCase().replace(/[^A-Z]/g, '') === decryptedText;
                
                document.getElementById('systemDiagnostics').textContent = 
                    `üîÑ –¢–µ—Å—Ç —Ü–∏–∫–ª–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ-—Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∞:\n` +
                    `–û—Ä–∏–≥–∏–Ω–∞–ª: ${originalText}\n` +
                    `–†–µ–∑—É–ª—å—Ç–∞—Ç: ${decryptedText}\n` +
                    `–°—Ç–∞—Ç—É—Å: ${success ? '‚úÖ –£–°–ü–ï–•' : '‚ùå –û–®–ò–ë–ö–ê'}`;
                    
            } catch (error) {
                document.getElementById('systemDiagnostics').textContent = `‚ùå –û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–∞: ${error.message}`;
            }
        }

        function fullAnalysis() {
            const stats = cipher.getSystemStats();
            const plaintext = document.getElementById('plainText').value;
            const freqAnalysis = cipher.frequencyAnalysis(plaintext);
            
            updateStatistics(stats);
            updateFrequencyAnalysis(freqAnalysis);
            updateMappingVisualization();
            
            document.getElementById('systemDiagnostics').textContent = 
                `üìä –ü–æ–ª–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∑–∞–≤–µ—Ä—à–µ–Ω\n` +
                `–≠–Ω—Ç—Ä–æ–ø–∏—è —Å–∏—Å—Ç–µ–º—ã: ${stats.entropy.toFixed(3)} –±–∏—Ç/—Å–∏–º–≤–æ–ª\n` +
                `–£—Ä–æ–≤–µ–Ω—å –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏: ${stats.securityLevel.toFixed(1)}%\n` +
                `–î—É–±–ª–∏–∫–∞—Ç—ã –≥–æ–º–æ—Ñ–æ–Ω–æ–≤: ${stats.duplicateHomophones}`;
        }

        function updateStatistics(stats) {
            document.getElementById('entropyValue').textContent = stats.entropy.toFixed(3);
            document.getElementById('homophoneCount').textContent = stats.totalHomophones;
            document.getElementById('bigramCount').textContent = stats.totalBigrams;
            document.getElementById('securityLevel').textContent = stats.securityLevel.toFixed(1) + '%';
        }

        function updateFrequencyAnalysis(freq) {
            let analysis = '–ß–∞—Å—Ç–æ—Ç–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞:\n';
            const sorted = Object.entries(freq).sort((a, b) => b[1] - a[1]);
            
            sorted.forEach(([char, count]) => {
                analysis += `${char}: ${count} (${(count / Object.values(freq).reduce((a, b) => a + b, 0) * 100).toFixed(1)}%)\n`;
            });
            
            document.getElementById('frequencyAnalysis').textContent = analysis;
        }

        function updateMappingVisualization() {
            const mappingDiv = document.getElementById('mappingVisualization');
            mappingDiv.innerHTML = '';
            
            let count = 0;
            for (const [bigram, homophones] of cipher.sBox.entries()) {
                if (count++ >= 50) break;
                
                const item = document.createElement('div');
                item.className = 'mapping-item';
                item.textContent = `${bigram} ‚Üí [${homophones.slice(0, 3).join(', ')}${homophones.length > 3 ? '...' : ''}] (${homophones.length})`;
                mappingDiv.appendChild(item);
            }
        }

        function analyzeCiphertext(ciphertext) {
            const entropy = cipher.calculateEntropy(ciphertext);
            document.getElementById('systemDiagnostics').textContent = 
                `üîç –ê–Ω–∞–ª–∏–∑ —à–∏—Ñ—Ä–æ—Ç–µ–∫—Å—Ç–∞:\n` +
                `–î–ª–∏–Ω–∞: ${ciphertext.length} —Å–∏–º–≤–æ–ª–æ–≤\n` +
                `–≠–Ω—Ç—Ä–æ–ø–∏—è: ${entropy.toFixed(3)} –±–∏—Ç/—Å–∏–º–≤–æ–ª\n` +
                `–†–∞–∑–º–µ—Ä: ${new Blob([ciphertext]).size} –±–∞–π—Ç`;
        }

        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        window.onload = initializeSystem;
    </script>
</body>
</html>
