<!DOCTYPE html>
<html>
<head>
  <title>H-Cipher Math Implementation</title>
  <script>
    //////////////////////////////////////////////////////////////////
    // ОСНОВНЫЕ МАТЕМАТИЧЕСКИЕ ФОРМУЛЫ ИЗ СПЕЦИФИКАЦИИ
    //////////////////////////////////////////////////////////////////

    // 1. Групповая операция: G = ⟨x, y, z | x² = y² = z² = 1, (xy)⁵ = (yz)⁷ = (xz)³ = 1⟩
    class HyperbolicGroup {
      static reduce(word) {
        // Алгоритм Дехна для приведения к нормальной форме
        const rules = [
          { from: 'xx', to: '' },
          { from: 'yy', to: '' },
          { from: 'zz', to: '' },
          { from: 'xyxyxyxyxy', to: '' },
          { from: 'yzyzyzyzyzyzy', to: '' },
          { from: 'xzxzxz', to: '' }
        ];

        let changed;
        do {
          changed = false;
          for (const rule of rules) {
            if (word.includes(rule.from)) {
              word = word.replace(rule.from, rule.to);
              changed = true;
            }
          }
        } while (changed);

        return word;
      }
    }

    // 2. Формула шифрования: C = NF(m·K⁻¹)·K' mod p
    class HCipher {
      constructor() {
        this.p = this.calculatePrime(); // p = 2³⁰⁷² - 2²⁵⁶ + 1
      }

      encrypt(m, K) {
        // 1. Приведение к нормальной форме
        const mNormalized = HyperbolicGroup.reduce(m);
        
        // 2. Вычисление m·K⁻¹
        const mKInv = this.groupMultiply(mNormalized, this.groupInverse(K));
        
        // 3. Нормальная форма
        const C = HyperbolicGroup.reduce(mKInv);
        
        // 4. Умножение на K'
        const KPrime = this.deriveKey(K, this.hash(m));
        return this.modularReduce(
          this.groupMultiply(C, KPrime),
          this.p
        );
      }

      decrypt(C, K) {
        // 1. Вычисление C·(K')⁻¹
        const KPrime = this.deriveKey(K, this.hash(this.groupMultiply(C, K)));
        const CKPrimeInv = this.groupMultiply(C, this.groupInverse(KPrime));
        
        // 2. Нормальная форма
        const mKInv = HyperbolicGroup.reduce(CKPrimeInv);
        
        // 3. Умножение на K
        return this.groupMultiply(mKInv, K);
      }

      //////////////////////////////////////////////////////////////////
      // ВСПОМОГАТЕЛЬНЫЕ МАТЕМАТИЧЕСКИЕ ФУНКЦИИ
      //////////////////////////////////////////////////////////////////

      calculatePrime() {
        // p = 2³⁰⁷² - 2²⁵⁶ + 1
        return BigInt(2)**BigInt(3072) - BigInt(2)**BigInt(256) + BigInt(1);
      }

      groupMultiply(a, b) {
        // Групповая операция в гиперболической группе
        return HyperbolicGroup.reduce(a + b);
      }

      groupInverse(w) {
        // Обратный элемент в группе
        return w.split('').reverse().map(c => {
          if (c === 'x') return 'x';
          if (c === 'y') return 'y';
          if (c === 'z') return 'z';
          return '';
        }).join('');
      }

      deriveKey(K, h) {
        // K' = Derive(K, hash(m))
        const Kh = this.groupMultiply(K, h);
        return HyperbolicGroup.reduce(Kh);
      }

      hash(m) {
        // Хеш-функция для группы
        let result = '';
        for (let i = 0; i < m.length; i++) {
          const c = m.charCodeAt(i);
          result += (c % 3 === 0) ? 'x' : (c % 3 === 1) ? 'y' : 'z';
        }
        return HyperbolicGroup.reduce(result);
      }

      modularReduce(value, mod) {
        // Модулярная редукция
        return (value % mod + mod) % mod;
      }
    }

    //////////////////////////////////////////////////////////////////
    // ИНТЕРФЕЙС ПОЛЬЗОВАТЕЛЯ
    //////////////////////////////////////////////////////////////////
    function encrypt() {
      const hcipher = new HCipher();
      const message = document.getElementById('message').value;
      const key = document.getElementById('key').value || 'xyz'; // Стандартный ключ

      // Преобразование сообщения в групповые элементы
      const groupElements = message.split('').map(c => {
        const code = c.charCodeAt(0);
        return (code % 3 === 0) ? 'x' : (code % 3 === 1) ? 'y' : 'z';
      }).join('');

      const encrypted = hcipher.encrypt(groupElements, key);
      document.getElementById('output').innerText = `Зашифровано: ${encrypted}`;
    }

    function decrypt() {
      const hcipher = new HCipher();
      const message = document.getElementById('message').value;
      const key = document.getElementById('key').value || 'xyz'; // Стандартный ключ

      const decrypted = hcipher.decrypt(message, key);
      
      // Обратное преобразование из групповых элементов
      let result = '';
      for (const c of decrypted) {
        if (c === 'x') result += String.fromCharCode(65); // A
        else if (c === 'y') result += String.fromCharCode(66); // B
        else if (c === 'z') result += String.fromCharCode(67); // C
      }
      
      document.getElementById('output').innerText = `Расшифровано: ${result}`;
    }
  </script>
</head>
<body>
  <h1>H-Cipher Mathematical Implementation</h1>
  <textarea id="message" rows="4" cols="50"></textarea><br>
  <input type="text" id="key" placeholder="Ключ (x, y или z)"><br>
  <button onclick="encrypt()">Шифровать</button>
  <button onclick="decrypt()">Дешифровать</button>
  <div id="output"></div>

  <h2>Формулы реализации:</h2>
  <ul>
    <li>Группа: G = ⟨x, y, z | x² = y² = z² = 1, (xy)⁵ = (yz)⁷ = (xz)³ = 1⟩</li>
    <li>Шифрование: C = NF(m·K⁻¹)·K' mod p</li>
    <li>Простое число: p = 2<sup>3072</sup> - 2<sup>256</sup> + 1</li>
    <li>Алгоритм Дехна для нормальной формы</li>
  </ul>
</body>
</html>
